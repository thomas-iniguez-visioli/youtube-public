{
  "issueNumber": 50,
  "created": "2026-02-17T13:21:35.213Z",
  "history": [
    {
      "timestamp": "2026-02-17T13:21:35.213Z",
      "role": "user",
      "content": {
        "number": 50,
        "title": "Error: net::ERR_INSUFFICIENT_RESOURCES",
        "body": "View details in Rollbar: [https://app.rollbar.com/a/thomas.iniguez/fix/item/FirstProject/27](https://app.rollbar.com/a/thomas.iniguez/fix/item/FirstProject/27)\n\n```\n\nError: net::ERR_INSUFFICIENT_RESOURCES\n  File \"node:electron/js2c/browser_init\", line 2, in SimpleURLLoaderWrapper.<anonymous>\n  File \"node:events\", line 518, in SimpleURLLoaderWrapper.emit\n```",
        "labels": [
          "bug",
          "complexity:medium"
        ],
        "author": "alphaleadership",
        "createdAt": "2026-02-17T13:19:04Z"
      },
      "metadata": {
        "event": "issue_opened/labeled"
      }
    },
    {
      "timestamp": "2026-02-17T13:21:43.206Z",
      "role": "assistant",
      "content": {
        "complexity": "medium",
        "type": "bug",
        "suggestedColumn": "a_faire",
        "acceptanceCriteria": [
          "The application no longer crashes or displays 'net::ERR_INSUFFICIENT_RESOURCES' errors during normal operation, particularly when interacting with external services.",
          "Any underlying resource leaks (e.g., network connections, memory, file handles) contributing to the error are identified and fixed.",
          "The application handles potential resource limitations gracefully, perhaps through improved error handling, retry mechanisms, or by limiting concurrent operations."
        ],
        "icon": "ðŸš¨",
        "color": "#FF4500",
        "missingInformation": {
          "isMissing": true,
          "details": [
            "Specific steps to reproduce the error (what action triggers it?).",
            "Contextual information about the environment (OS, Electron version, Node.js version) if not detailed in Rollbar.",
            "Details about the network requests being made when the error occurs (e.g., target URL, number of concurrent requests, size of responses).",
            "Is the error consistently reproducible, or does it happen intermittently?"
          ]
        },
        "fileActions": [
          {
            "action": "read",
            "path": "src/gemini/api-client.js",
            "explanation": "To understand how API requests to the Gemini service are made, including concurrency controls and resource handling, which might lead to the 'INSUFFICIENT_RESOURCES' error."
          },
          {
            "action": "read",
            "path": "src/github/api-client.js",
            "explanation": "To examine how API requests to GitHub are managed, looking for patterns that could exhaust network or system resources."
          },
          {
            "action": "read",
            "path": "src/gemini/analyzer.js",
            "explanation": "To determine if the analyzer performs any operations (e.g., fetching large files, numerous concurrent requests) that could strain system resources."
          }
        ]
      },
      "metadata": {
        "type": "analysis",
        "iteration": 0
      }
    },
    {
      "timestamp": "2026-02-17T13:21:43.207Z",
      "role": "system",
      "content": [
        {
          "path": "src/gemini/api-client.js",
          "content": "import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { delay as defaultDelay } from '../utils/helpers.js';\n\nexport class GeminiClient {\n  constructor(apiKey, modelOrOptions = 'gemini-2.5-flash', delayFn = defaultDelay) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.delay = delayFn;\n    const options = typeof modelOrOptions === 'string'\n      ? { primaryModel: modelOrOptions }\n      : (modelOrOptions || {});\n\n    this.primaryModel = options.primaryModel || 'gemini-2.5-flash';\n    this.fallbackModels = (options.fallbackModels || []).filter(Boolean);\n    this.retries = Number.isInteger(options.retries) && options.retries >= 0 ? options.retries : 3;\n    this.models = new Map();\n  }\n\n  getModel(modelName) {\n    if (!this.models.has(modelName)) {\n      this.models.set(modelName, this.genAI.getGenerativeModel({ model: modelName }));\n    }\n    return this.models.get(modelName);\n  }\n\n  getCandidateModels(preferredModel) {\n    const candidates = [preferredModel, this.primaryModel, ...this.fallbackModels].filter(Boolean);\n    return [...new Set(candidates)];\n  }\n\n  async generateContent(prompt, retries = this.retries, options = {}) {\n    let lastError;\n    const candidateModels = this.getCandidateModels(options.preferredModel);\n\n    for (let i = 0; i <= retries; i++) {\n      for (const modelName of candidateModels) {\n        try {\n          const model = this.getModel(modelName);\n          const result = await model.generateContent(prompt);\n          const response = await result.response;\n          return response.text();\n        } catch (error) {\n          lastError = error;\n        }\n      }\n\n      if (i < retries) {\n        const waitTime = Math.pow(2, i) * 2000; // Increased base from 1000 to 2000\n        console.log(`Rate limited or error occurred. Waiting ${waitTime}ms before retry ${i + 1}...`);\n        await this.delay(waitTime);\n      }\n    }\n\n    throw lastError;\n  }\n\n  async generateJson(prompt, retries = this.retries, options = {}) {\n      const jsonPrompt = `${prompt}\n\nIMPORTANT: Return ONLY valid JSON.`;\n      const text = await this.generateContent(jsonPrompt, retries, options);\n      try {\n          // Find JSON block if it exists\n          const jsonMatch = text.match(/\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]/);\n          const jsonStr = jsonMatch ? jsonMatch[0] : text;\n          return JSON.parse(jsonStr);\n      } catch (error) {\n          throw new Error(`Failed to parse Gemini response as JSON: ${error.message}\nResponse: ${text}`);\n      }\n  }\n}\n"
        },
        {
          "path": "src/github/api-client.js",
          "content": "import { Octokit } from '@octokit/rest';\n\nexport class GitHubClient {\n  constructor(token, repoPath) {\n    this.octokit = new Octokit({ auth: token });\n    const [owner, repo] = repoPath.split('/');\n    this.owner = owner;\n    this.repo = repo;\n  }\n\n  async getIssue(issueNumber) {\n    const { data } = await this.octokit.issues.get({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber\n    });\n    return data;\n  }\n\n  async createComment(issueNumber, body) {\n    const { data } = await this.octokit.issues.createComment({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      body\n    });\n    return data;\n  }\n\n  async addLabels(issueNumber, labels) {\n    const { data } = await this.octokit.issues.addLabels({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      labels\n    });\n    return data;\n  }\n\n  async getRef(ref) {\n      const { data } = await this.octokit.git.getRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`\n      });\n      return data;\n  }\n\n  async createRef(ref, sha) {\n      const { data } = await this.octokit.git.createRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `refs/heads/${ref}`,\n          sha\n      });\n      return data;\n  }\n\n  async createCommit(message, tree, parents) {\n      const { data } = await this.octokit.git.createCommit({\n          owner: this.owner,\n          repo: this.repo,\n          message,\n          tree,\n          parents\n      });\n      return data;\n  }\n\n  async updateRef(ref, sha) {\n      await this.octokit.git.updateRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`,\n          sha\n      });\n  }\n\n  async getDefaultBranch() {\n    const { data } = await this.octokit.repos.get({\n      owner: this.owner,\n      repo: this.repo\n    });\n    return data.default_branch;\n  }\n\n  async createPullRequest(title, body, head, base) {\n    const { data } = await this.octokit.pulls.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      head,\n      base\n    });\n    return data;\n  }\n\n  async createIssue(title, body, labels = []) {\n    const { data } = await this.octokit.issues.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      labels\n    });\n    return data;\n  }\n\n  async getLatestCommitSha(branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const { data } = await this.octokit.repos.getBranch({\n          owner: this.owner,\n          repo: this.repo,\n          branch: targetBranch\n      });\n      return data.commit.sha;\n  }\n  \n  async commitFile(filePath, content, message, branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const sha = await this.getLatestCommitSha(targetBranch);\n      const { data: commit } = await this.octokit.git.getCommit({\n          owner: this.owner,\n          repo: this.repo,\n          commit_sha: sha\n      });\n      \n      const { data: blob } = await this.octokit.git.createBlob({\n          owner: this.owner,\n          repo: this.repo,\n          content,\n          encoding: 'utf-8'\n      });\n\n      const { data: tree } = await this.octokit.git.createTree({\n          owner: this.owner,\n          repo: this.repo,\n          base_tree: commit.tree.sha,\n          tree: [{\n              path: filePath,\n              mode: '100644',\n              type: 'blob',\n              sha: blob.sha\n          }]\n      });\n\n      const newCommit = await this.createCommit(message, tree.sha, [sha]);\n      await this.updateRef(targetBranch, newCommit.sha);\n      return newCommit;\n  }\n}\n"
        },
        {
          "path": "src/gemini/analyzer.js",
          "content": "import { KANBAN_COLUMNS } from '../utils/constants.js';\nimport { getProjectStructure } from '../utils/helpers.js';\n\nexport class IssueAnalyzer {\n  constructor(client) {\n    this.client = client;\n  }\n\n  async analyzeIssue(issueData, history = []) {\n    const maxBodyLength = 4000;\n    const trimmedBody = (issueData.body || '').slice(0, maxBodyLength);\n    const bodyWasTrimmed = (issueData.body || '').length > maxBodyLength;\n    const preferredModel = (issueData.body || '').length > 8000 ? 'gemini-2.5-pro' : undefined;\n\n    const projectStructure = await getProjectStructure();\n    \n    const historyContext = history.length > 0 \n      ? `\\nDialogue History:\\n${history.map(h => `[${h.role}] ${JSON.stringify(h.content)}`).join('\\n')}`\n      : '';\n\n    const prompt = `\n      Analyze the following GitHub issue and provide a structured JSON response.\n      ${historyContext}\n      \n      Issue Title: ${issueData.title}\n      Issue Body: ${trimmedBody}\n      ${bodyWasTrimmed ? 'Note: The body was truncated for performance. Prioritize key technical points.' : ''}\n      Labels: ${issueData.labels.join(', ')}\n\n      Current Project Structure:\n      ${projectStructure}\n      \n      Requirements:\n      1. Assess technical complexity (low, medium, high).\n      2. Classify the issue (bug, feature, question).\n      3. Suggest a Kanban column (${Object.values(KANBAN_COLUMNS).join(', ')}).\n      4. Generate at least 3 testable acceptance criteria.\n      5. Identify if any information is missing (true/false) and list what's missing.\n      6. Choose a representative emoji icon for the task.\n      7. Choose a representative hex color code for the task (e.g. #FF5733).\n      8. If the issue implies reading or modifying files to understand or fix it, specify \"fileActions\".\n         - Use \"read\" to request content of a file.\n         - Use \"write\" to create/overwrite a file.\n         - Use \"patch\" to replace a specific block of text in a file.\n      \n      Return JSON format:\n      {\n        \"complexity\": \"low|medium|high\",\n        \"type\": \"bug|feature|question\",\n        \"suggestedColumn\": \"...\",\n        \"acceptanceCriteria\": [\"...\", \"...\", \"...\"],\n        \"icon\": \"...\",\n        \"color\": \"#...\",\n        \"missingInformation\": {\n          \"isMissing\": false,\n          \"details\": []\n        },\n        \"fileActions\": [\n          {\n            \"action\": \"read|write|patch\",\n            \"path\": \"relative/path/to/file\",\n            \"content\": \"Full content for 'write' action\",\n            \"oldContent\": \"Exact block of text to find for 'patch' action\",\n            \"newContent\": \"Replacement text for 'patch' action\",\n            \"explanation\": \"Why this action is needed\"\n          }\n        ]\n      }\n    `;\n\n    const analysis = await this.client.generateJson(prompt, undefined, { preferredModel });\n    return analysis;\n  }\n\n  async generateClarificationDiscussion(issueData, missingDetails = []) {\n    if (!missingDetails.length) {\n      return {\n        summary: 'No blocking information is missing.',\n        questions: [],\n        requestedInputs: []\n      };\n    }\n\n    const prompt = `\n      You are preparing a follow-up discussion comment for a GitHub issue.\n\n      Issue title: ${issueData.title}\n      Issue body: ${(issueData.body || '').slice(0, 2000)}\n      Missing details identified by a previous analysis: ${missingDetails.join('; ')}\n\n      Produce a JSON response in French with:\n      - summary: one short sentence explaining why additional info is needed.\n      - questions: an array of 2 to 5 concrete clarification questions.\n      - requestedInputs: an array of concrete elements the user can provide (logs, reproduction steps, screenshots, design constraints, etc.).\n\n      Return JSON format:\n      {\n        \"summary\": \"...\",\n        \"questions\": [\"...\"],\n        \"requestedInputs\": [\"...\"]\n      }\n    `;\n\n    return this.client.generateJson(prompt);\n  }\n}\n"
        }
      ],
      "metadata": {
        "type": "file_read_results"
      }
    },
    {
      "timestamp": "2026-02-17T13:22:15.460Z",
      "role": "assistant",
      "content": {
        "complexity": "medium",
        "type": "bug",
        "suggestedColumn": "a_faire",
        "acceptanceCriteria": [
          "The application no longer encounters `net::ERR_INSUFFICIENT_RESOURCES` errors, even under load or when performing multiple concurrent external API requests.",
          "Concurrency limits are properly implemented for Gemini and GitHub API calls to prevent resource exhaustion.",
          "Error handling for external API calls explicitly catches and differentiates resource-related errors, providing clearer diagnostics.",
          "The application's memory and network resource usage remains within acceptable limits during operation, specifically when making API calls."
        ],
        "icon": "ðŸš¨",
        "color": "#FF4500",
        "missingInformation": {
          "isMissing": true,
          "details": [
            "Specific steps to reproduce the error (what exact actions precede the error?).",
            "Contextual information about the environment where the error occurs (OS, Electron version, Node.js version).",
            "Details about the volume and nature of network requests being made when the error occurs (e.g., how many concurrent Gemini/GitHub API calls, approximate size of payloads/responses).",
            "Is the error consistently reproducible, or does it happen intermittently and under what conditions?",
            "Any additional logs from the Electron renderer process or network tab that show resource warnings or failures."
          ]
        },
        "fileActions": [
          {
            "action": "read",
            "path": "src/gemini/api-client.js",
            "explanation": "To understand and potentially implement concurrency limits for Gemini API requests, as the current implementation lacks global concurrency control which could lead to resource exhaustion if many calls are made in parallel."
          },
          {
            "action": "read",
            "path": "src/github/api-client.js",
            "explanation": "To understand and potentially implement concurrency limits for GitHub API requests, as the current implementation lacks global concurrency control which could lead to resource exhaustion if many calls are made in parallel."
          },
          {
            "action": "read",
            "path": "src/gemini/analyzer.js",
            "explanation": "To analyze the frequency, payload size, and overall usage patterns of GeminiClient calls initiated by the analyzer, which could contribute to the 'INSUFFICIENT_RESOURCES' error."
          },
          {
            "action": "read",
            "path": "action.js",
            "explanation": "To understand the main entry point and overall execution flow of the application, identifying where Gemini and GitHub API clients are instantiated and how they are utilized, potentially pinpointing areas of high concurrency."
          },
          {
            "action": "read",
            "path": "src/github/issue-processor.js",
            "explanation": "To investigate how issue processing interacts with GitHub and Gemini APIs, as this could be a source of numerous concurrent requests that overwhelm system resources."
          }
        ]
      },
      "metadata": {
        "type": "analysis",
        "iteration": 1
      }
    },
    {
      "timestamp": "2026-02-17T13:22:15.462Z",
      "role": "system",
      "content": [
        {
          "path": "src/gemini/api-client.js",
          "content": "import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { delay as defaultDelay } from '../utils/helpers.js';\n\nexport class GeminiClient {\n  constructor(apiKey, modelOrOptions = 'gemini-2.5-flash', delayFn = defaultDelay) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.delay = delayFn;\n    const options = typeof modelOrOptions === 'string'\n      ? { primaryModel: modelOrOptions }\n      : (modelOrOptions || {});\n\n    this.primaryModel = options.primaryModel || 'gemini-2.5-flash';\n    this.fallbackModels = (options.fallbackModels || []).filter(Boolean);\n    this.retries = Number.isInteger(options.retries) && options.retries >= 0 ? options.retries : 3;\n    this.models = new Map();\n  }\n\n  getModel(modelName) {\n    if (!this.models.has(modelName)) {\n      this.models.set(modelName, this.genAI.getGenerativeModel({ model: modelName }));\n    }\n    return this.models.get(modelName);\n  }\n\n  getCandidateModels(preferredModel) {\n    const candidates = [preferredModel, this.primaryModel, ...this.fallbackModels].filter(Boolean);\n    return [...new Set(candidates)];\n  }\n\n  async generateContent(prompt, retries = this.retries, options = {}) {\n    let lastError;\n    const candidateModels = this.getCandidateModels(options.preferredModel);\n\n    for (let i = 0; i <= retries; i++) {\n      for (const modelName of candidateModels) {\n        try {\n          const model = this.getModel(modelName);\n          const result = await model.generateContent(prompt);\n          const response = await result.response;\n          return response.text();\n        } catch (error) {\n          lastError = error;\n        }\n      }\n\n      if (i < retries) {\n        const waitTime = Math.pow(2, i) * 2000; // Increased base from 1000 to 2000\n        console.log(`Rate limited or error occurred. Waiting ${waitTime}ms before retry ${i + 1}...`);\n        await this.delay(waitTime);\n      }\n    }\n\n    throw lastError;\n  }\n\n  async generateJson(prompt, retries = this.retries, options = {}) {\n      const jsonPrompt = `${prompt}\n\nIMPORTANT: Return ONLY valid JSON.`;\n      const text = await this.generateContent(jsonPrompt, retries, options);\n      try {\n          // Find JSON block if it exists\n          const jsonMatch = text.match(/\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]/);\n          const jsonStr = jsonMatch ? jsonMatch[0] : text;\n          return JSON.parse(jsonStr);\n      } catch (error) {\n          throw new Error(`Failed to parse Gemini response as JSON: ${error.message}\nResponse: ${text}`);\n      }\n  }\n}\n"
        },
        {
          "path": "src/github/api-client.js",
          "content": "import { Octokit } from '@octokit/rest';\n\nexport class GitHubClient {\n  constructor(token, repoPath) {\n    this.octokit = new Octokit({ auth: token });\n    const [owner, repo] = repoPath.split('/');\n    this.owner = owner;\n    this.repo = repo;\n  }\n\n  async getIssue(issueNumber) {\n    const { data } = await this.octokit.issues.get({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber\n    });\n    return data;\n  }\n\n  async createComment(issueNumber, body) {\n    const { data } = await this.octokit.issues.createComment({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      body\n    });\n    return data;\n  }\n\n  async addLabels(issueNumber, labels) {\n    const { data } = await this.octokit.issues.addLabels({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      labels\n    });\n    return data;\n  }\n\n  async getRef(ref) {\n      const { data } = await this.octokit.git.getRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`\n      });\n      return data;\n  }\n\n  async createRef(ref, sha) {\n      const { data } = await this.octokit.git.createRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `refs/heads/${ref}`,\n          sha\n      });\n      return data;\n  }\n\n  async createCommit(message, tree, parents) {\n      const { data } = await this.octokit.git.createCommit({\n          owner: this.owner,\n          repo: this.repo,\n          message,\n          tree,\n          parents\n      });\n      return data;\n  }\n\n  async updateRef(ref, sha) {\n      await this.octokit.git.updateRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`,\n          sha\n      });\n  }\n\n  async getDefaultBranch() {\n    const { data } = await this.octokit.repos.get({\n      owner: this.owner,\n      repo: this.repo\n    });\n    return data.default_branch;\n  }\n\n  async createPullRequest(title, body, head, base) {\n    const { data } = await this.octokit.pulls.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      head,\n      base\n    });\n    return data;\n  }\n\n  async createIssue(title, body, labels = []) {\n    const { data } = await this.octokit.issues.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      labels\n    });\n    return data;\n  }\n\n  async getLatestCommitSha(branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const { data } = await this.octokit.repos.getBranch({\n          owner: this.owner,\n          repo: this.repo,\n          branch: targetBranch\n      });\n      return data.commit.sha;\n  }\n  \n  async commitFile(filePath, content, message, branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const sha = await this.getLatestCommitSha(targetBranch);\n      const { data: commit } = await this.octokit.git.getCommit({\n          owner: this.owner,\n          repo: this.repo,\n          commit_sha: sha\n      });\n      \n      const { data: blob } = await this.octokit.git.createBlob({\n          owner: this.owner,\n          repo: this.repo,\n          content,\n          encoding: 'utf-8'\n      });\n\n      const { data: tree } = await this.octokit.git.createTree({\n          owner: this.owner,\n          repo: this.repo,\n          base_tree: commit.tree.sha,\n          tree: [{\n              path: filePath,\n              mode: '100644',\n              type: 'blob',\n              sha: blob.sha\n          }]\n      });\n\n      const newCommit = await this.createCommit(message, tree.sha, [sha]);\n      await this.updateRef(targetBranch, newCommit.sha);\n      return newCommit;\n  }\n}\n"
        },
        {
          "path": "src/gemini/analyzer.js",
          "content": "import { KANBAN_COLUMNS } from '../utils/constants.js';\nimport { getProjectStructure } from '../utils/helpers.js';\n\nexport class IssueAnalyzer {\n  constructor(client) {\n    this.client = client;\n  }\n\n  async analyzeIssue(issueData, history = []) {\n    const maxBodyLength = 4000;\n    const trimmedBody = (issueData.body || '').slice(0, maxBodyLength);\n    const bodyWasTrimmed = (issueData.body || '').length > maxBodyLength;\n    const preferredModel = (issueData.body || '').length > 8000 ? 'gemini-2.5-pro' : undefined;\n\n    const projectStructure = await getProjectStructure();\n    \n    const historyContext = history.length > 0 \n      ? `\\nDialogue History:\\n${history.map(h => `[${h.role}] ${JSON.stringify(h.content)}`).join('\\n')}`\n      : '';\n\n    const prompt = `\n      Analyze the following GitHub issue and provide a structured JSON response.\n      ${historyContext}\n      \n      Issue Title: ${issueData.title}\n      Issue Body: ${trimmedBody}\n      ${bodyWasTrimmed ? 'Note: The body was truncated for performance. Prioritize key technical points.' : ''}\n      Labels: ${issueData.labels.join(', ')}\n\n      Current Project Structure:\n      ${projectStructure}\n      \n      Requirements:\n      1. Assess technical complexity (low, medium, high).\n      2. Classify the issue (bug, feature, question).\n      3. Suggest a Kanban column (${Object.values(KANBAN_COLUMNS).join(', ')}).\n      4. Generate at least 3 testable acceptance criteria.\n      5. Identify if any information is missing (true/false) and list what's missing.\n      6. Choose a representative emoji icon for the task.\n      7. Choose a representative hex color code for the task (e.g. #FF5733).\n      8. If the issue implies reading or modifying files to understand or fix it, specify \"fileActions\".\n         - Use \"read\" to request content of a file.\n         - Use \"write\" to create/overwrite a file.\n         - Use \"patch\" to replace a specific block of text in a file.\n      \n      Return JSON format:\n      {\n        \"complexity\": \"low|medium|high\",\n        \"type\": \"bug|feature|question\",\n        \"suggestedColumn\": \"...\",\n        \"acceptanceCriteria\": [\"...\", \"...\", \"...\"],\n        \"icon\": \"...\",\n        \"color\": \"#...\",\n        \"missingInformation\": {\n          \"isMissing\": false,\n          \"details\": []\n        },\n        \"fileActions\": [\n          {\n            \"action\": \"read|write|patch\",\n            \"path\": \"relative/path/to/file\",\n            \"content\": \"Full content for 'write' action\",\n            \"oldContent\": \"Exact block of text to find for 'patch' action\",\n            \"newContent\": \"Replacement text for 'patch' action\",\n            \"explanation\": \"Why this action is needed\"\n          }\n        ]\n      }\n    `;\n\n    const analysis = await this.client.generateJson(prompt, undefined, { preferredModel });\n    return analysis;\n  }\n\n  async generateClarificationDiscussion(issueData, missingDetails = []) {\n    if (!missingDetails.length) {\n      return {\n        summary: 'No blocking information is missing.',\n        questions: [],\n        requestedInputs: []\n      };\n    }\n\n    const prompt = `\n      You are preparing a follow-up discussion comment for a GitHub issue.\n\n      Issue title: ${issueData.title}\n      Issue body: ${(issueData.body || '').slice(0, 2000)}\n      Missing details identified by a previous analysis: ${missingDetails.join('; ')}\n\n      Produce a JSON response in French with:\n      - summary: one short sentence explaining why additional info is needed.\n      - questions: an array of 2 to 5 concrete clarification questions.\n      - requestedInputs: an array of concrete elements the user can provide (logs, reproduction steps, screenshots, design constraints, etc.).\n\n      Return JSON format:\n      {\n        \"summary\": \"...\",\n        \"questions\": [\"...\"],\n        \"requestedInputs\": [\"...\"]\n      }\n    `;\n\n    return this.client.generateJson(prompt);\n  }\n}\n"
        },
        {
          "path": "action.js",
          "content": "import * as core from '@actions/core';\nimport * as github from '@actions/github';\nimport { validateAndGetConfig } from './src/config/index.js';\nimport { GitHubClient } from './src/github/api-client.js';\nimport { GeminiClient } from './src/gemini/api-client.js';\nimport { IssueAnalyzer } from './src/gemini/analyzer.js';\nimport { BranchManager } from './src/github/branch-manager.js';\nimport { WorkflowManager } from './src/workflow/manager.js';\n\nasync function run() {\n  let config;\n  const CENTRAL_REPO = 'alphaleadership/kanbanaction';\n\n  try {\n    config = validateAndGetConfig();\n\n    if (config.debug) {\n        console.log('Debug mode enabled');\n        console.log('Context:', JSON.stringify(github.context, null, 2));\n    }\n\n    const githubClient = new GitHubClient(config.githubToken, config.githubRepo);\n\n    if (config.installWorkflows) {\n      const workflowInstaller = new WorkflowManager(githubClient, null, null, null);\n      await workflowInstaller.installWorkflows();\n      console.log('Workflow installation completed. Skipping event processing.');\n      return;\n    }\n\n    const geminiClient = new GeminiClient(config.geminiApiKey, {\n      primaryModel: config.geminiModel,\n      fallbackModels: config.geminiFallbackModels,\n      retries: config.geminiRetries\n    });\n    const analyzer = new IssueAnalyzer(geminiClient);\n    const branchManager = new BranchManager(githubClient);\n    const workflow = new WorkflowManager(githubClient, geminiClient, analyzer, branchManager);\n\n    const context = github.context;\n    \n    if (context.eventName === 'issues' && (context.payload.action === 'opened' || context.payload.action === 'labeled')) {\n      const issueNumber = context.payload.issue.number;\n      await workflow.processGitHubIssue(issueNumber);\n    } else if (context.eventName === 'pull_request' && context.payload.action === 'closed' && context.payload.pull_request.merged) {\n      const prNumber = context.payload.pull_request.number;\n      await workflow.processPullRequestMerge(prNumber);\n    } else if (context.eventName === 'workflow_dispatch' || context.eventName === 'schedule') {\n      console.log(`Triggered by ${context.eventName}. Processing pending tasks...`);\n      await workflow.processPendingTasks();\n    } else {\n      console.log(`Event ${context.eventName} with action ${context.payload.action} is not handled.`);\n    }\n\n      } catch (error) {\n        core.setFailed(error.message);\n        if (config?.debug) {\n          console.error('Detailed Error:', error);\n          console.error('Error Stack:', error.stack);\n        }\n    if (!config?.githubToken) {\n      console.error('Skipping centralized error report because no GitHub token is configured.');\n      return;\n    }\n    \n    try {\n      console.log(`Reporting error to central repository: ${CENTRAL_REPO}`);\n      const centralClient = new GitHubClient(config.githubToken, CENTRAL_REPO);\n      const errorTitle = `Error in ${github.context.payload.repository?.full_name || 'unknown repo'}: ${error.message.substring(0, 50)}...`;\n      const errorBody = `\n### Error Details\n- **Repository:** ${github.context.payload.repository?.full_name || 'Unknown'}\n- **Event:** ${github.context.eventName}\n- **Action:** ${github.context.payload.action || 'N/A'}\n- **Error Message:** ${error.message}\n\n### Stack Trace\n\\`\\`\\`\n${error.stack}\n\\`\\`\\`\n\n### Context\n<details>\n<summary>GitHub Context</summary>\n\n\\`\\`\\`json\n${JSON.stringify(github.context, null, 2)}\n\\`\\`\\`\n</details>\n      `;\n      \n      await centralClient.createIssue(errorTitle, errorBody, ['bug', 'automated-report']);\n    } catch (reportError) {\n      console.error('Failed to report error to central repository:', reportError.message);\n    }\n  }\n}\n\nrun();\n"
        },
        {
          "path": "src/github/issue-processor.js",
          "content": "export function extractIssueData(issue) {\n  if (!issue) return null;\n\n  return {\n    number: issue.number,\n    title: issue.title,\n    body: issue.body || '',\n    labels: issue.labels.map(l => typeof l === 'string' ? l : l.name),\n    author: issue.user.login,\n    createdAt: issue.created_at\n  };\n}\n\nexport function detectIssueType(issueData) {\n    const labels = issueData.labels.map(l => l.toLowerCase());\n    if (labels.includes('bug')) return 'bug';\n    if (labels.includes('feature') || labels.includes('enhancement')) return 'feature';\n    if (labels.includes('question')) return 'question';\n    return 'feature'; // Default\n}\n\nexport function shouldProcessIssue(issueData, config) {\n    // If we have a label filter, check it\n    if (config.labelFilter && config.labelFilter.length > 0) {\n        return issueData.labels.some(l => config.labelFilter.includes(l));\n    }\n    return true;\n}\n"
        }
      ],
      "metadata": {
        "type": "file_read_results"
      }
    },
    {
      "timestamp": "2026-02-17T13:23:14.436Z",
      "role": "assistant",
      "content": {
        "complexity": "medium",
        "type": "bug",
        "suggestedColumn": "a_faire",
        "acceptanceCriteria": [
          "The application no longer encounters `net::ERR_INSUFFICIENT_RESOURCES` errors, even under load or when performing multiple concurrent external API requests.",
          "Concurrency limits are properly implemented for Gemini and GitHub API calls to prevent resource exhaustion.",
          "Error handling for external API calls explicitly catches and differentiates resource-related errors, providing clearer diagnostics.",
          "The application's memory and network resource usage remains within acceptable limits during operation, specifically when making API calls."
        ],
        "icon": "ðŸš¨",
        "color": "#FF4500",
        "missingInformation": {
          "isMissing": true,
          "details": [
            "Specific steps to reproduce the error (what exact actions precede the error?).",
            "Contextual information about the environment where the error occurs (OS, Electron version, Node.js version).",
            "Details about the volume and nature of network requests being made when the error occurs (e.g., how many concurrent Gemini/GitHub API calls, approximate size of payloads/responses).",
            "Is the error consistently reproducible, or does it happen intermittently and under what conditions?",
            "Any additional logs from the Electron renderer process or network tab that show resource warnings or failures."
          ]
        },
        "fileActions": [
          {
            "action": "read",
            "path": "src/gemini/api-client.js",
            "explanation": "To understand and potentially implement concurrency limits for Gemini API requests, as the current implementation lacks global concurrency control which could lead to resource exhaustion if many calls are made in parallel."
          },
          {
            "action": "read",
            "path": "src/github/api-client.js",
            "explanation": "To understand and potentially implement concurrency limits for GitHub API requests, as the current implementation lacks global concurrency control which could lead to resource exhaustion if many calls are made in parallel."
          },
          {
            "action": "read",
            "path": "src/gemini/analyzer.js",
            "explanation": "To analyze the frequency, payload size, and overall usage patterns of GeminiClient calls initiated by the analyzer, which could contribute to the 'INSUFFICIENT_RESOURCES' error."
          },
          {
            "action": "read",
            "path": "action.js",
            "explanation": "To understand the main entry point and overall execution flow of the application, identifying where Gemini and GitHub API clients are instantiated and how they are utilized, potentially pinpointing areas of high concurrency."
          },
          {
            "action": "read",
            "path": "src/workflow/manager.js",
            "explanation": "To investigate how the main workflow logic orchestrates calls to IssueAnalyzer (which uses GeminiClient) and BranchManager (which uses GitHubClient), as this class centralizes the primary operations that could lead to numerous concurrent requests."
          }
        ]
      },
      "metadata": {
        "type": "analysis",
        "iteration": 2
      }
    },
    {
      "timestamp": "2026-02-17T13:23:14.438Z",
      "role": "system",
      "content": [
        {
          "path": "src/gemini/api-client.js",
          "content": "import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { delay as defaultDelay } from '../utils/helpers.js';\n\nexport class GeminiClient {\n  constructor(apiKey, modelOrOptions = 'gemini-2.5-flash', delayFn = defaultDelay) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.delay = delayFn;\n    const options = typeof modelOrOptions === 'string'\n      ? { primaryModel: modelOrOptions }\n      : (modelOrOptions || {});\n\n    this.primaryModel = options.primaryModel || 'gemini-2.5-flash';\n    this.fallbackModels = (options.fallbackModels || []).filter(Boolean);\n    this.retries = Number.isInteger(options.retries) && options.retries >= 0 ? options.retries : 3;\n    this.models = new Map();\n  }\n\n  getModel(modelName) {\n    if (!this.models.has(modelName)) {\n      this.models.set(modelName, this.genAI.getGenerativeModel({ model: modelName }));\n    }\n    return this.models.get(modelName);\n  }\n\n  getCandidateModels(preferredModel) {\n    const candidates = [preferredModel, this.primaryModel, ...this.fallbackModels].filter(Boolean);\n    return [...new Set(candidates)];\n  }\n\n  async generateContent(prompt, retries = this.retries, options = {}) {\n    let lastError;\n    const candidateModels = this.getCandidateModels(options.preferredModel);\n\n    for (let i = 0; i <= retries; i++) {\n      for (const modelName of candidateModels) {\n        try {\n          const model = this.getModel(modelName);\n          const result = await model.generateContent(prompt);\n          const response = await result.response;\n          return response.text();\n        } catch (error) {\n          lastError = error;\n        }\n      }\n\n      if (i < retries) {\n        const waitTime = Math.pow(2, i) * 2000; // Increased base from 1000 to 2000\n        console.log(`Rate limited or error occurred. Waiting ${waitTime}ms before retry ${i + 1}...`);\n        await this.delay(waitTime);\n      }\n    }\n\n    throw lastError;\n  }\n\n  async generateJson(prompt, retries = this.retries, options = {}) {\n      const jsonPrompt = `${prompt}\n\nIMPORTANT: Return ONLY valid JSON.`;\n      const text = await this.generateContent(jsonPrompt, retries, options);\n      try {\n          // Find JSON block if it exists\n          const jsonMatch = text.match(/\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]/);\n          const jsonStr = jsonMatch ? jsonMatch[0] : text;\n          return JSON.parse(jsonStr);\n      } catch (error) {\n          throw new Error(`Failed to parse Gemini response as JSON: ${error.message}\nResponse: ${text}`);\n      }\n  }\n}\n"
        },
        {
          "path": "src/github/api-client.js",
          "content": "import { Octokit } from '@octokit/rest';\n\nexport class GitHubClient {\n  constructor(token, repoPath) {\n    this.octokit = new Octokit({ auth: token });\n    const [owner, repo] = repoPath.split('/');\n    this.owner = owner;\n    this.repo = repo;\n  }\n\n  async getIssue(issueNumber) {\n    const { data } = await this.octokit.issues.get({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber\n    });\n    return data;\n  }\n\n  async createComment(issueNumber, body) {\n    const { data } = await this.octokit.issues.createComment({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      body\n    });\n    return data;\n  }\n\n  async addLabels(issueNumber, labels) {\n    const { data } = await this.octokit.issues.addLabels({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      labels\n    });\n    return data;\n  }\n\n  async getRef(ref) {\n      const { data } = await this.octokit.git.getRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`\n      });\n      return data;\n  }\n\n  async createRef(ref, sha) {\n      const { data } = await this.octokit.git.createRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `refs/heads/${ref}`,\n          sha\n      });\n      return data;\n  }\n\n  async createCommit(message, tree, parents) {\n      const { data } = await this.octokit.git.createCommit({\n          owner: this.owner,\n          repo: this.repo,\n          message,\n          tree,\n          parents\n      });\n      return data;\n  }\n\n  async updateRef(ref, sha) {\n      await this.octokit.git.updateRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`,\n          sha\n      });\n  }\n\n  async getDefaultBranch() {\n    const { data } = await this.octokit.repos.get({\n      owner: this.owner,\n      repo: this.repo\n    });\n    return data.default_branch;\n  }\n\n  async createPullRequest(title, body, head, base) {\n    const { data } = await this.octokit.pulls.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      head,\n      base\n    });\n    return data;\n  }\n\n  async createIssue(title, body, labels = []) {\n    const { data } = await this.octokit.issues.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      labels\n    });\n    return data;\n  }\n\n  async getLatestCommitSha(branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const { data } = await this.octokit.repos.getBranch({\n          owner: this.owner,\n          repo: this.repo,\n          branch: targetBranch\n      });\n      return data.commit.sha;\n  }\n  \n  async commitFile(filePath, content, message, branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const sha = await this.getLatestCommitSha(targetBranch);\n      const { data: commit } = await this.octokit.git.getCommit({\n          owner: this.owner,\n          repo: this.repo,\n          commit_sha: sha\n      });\n      \n      const { data: blob } = await this.octokit.git.createBlob({\n          owner: this.owner,\n          repo: this.repo,\n          content,\n          encoding: 'utf-8'\n      });\n\n      const { data: tree } = await this.octokit.git.createTree({\n          owner: this.owner,\n          repo: this.repo,\n          base_tree: commit.tree.sha,\n          tree: [{\n              path: filePath,\n              mode: '100644',\n              type: 'blob',\n              sha: blob.sha\n          }]\n      });\n\n      const newCommit = await this.createCommit(message, tree.sha, [sha]);\n      await this.updateRef(targetBranch, newCommit.sha);\n      return newCommit;\n  }\n}\n"
        },
        {
          "path": "src/gemini/analyzer.js",
          "content": "import { KANBAN_COLUMNS } from '../utils/constants.js';\nimport { getProjectStructure } from '../utils/helpers.js';\n\nexport class IssueAnalyzer {\n  constructor(client) {\n    this.client = client;\n  }\n\n  async analyzeIssue(issueData, history = []) {\n    const maxBodyLength = 4000;\n    const trimmedBody = (issueData.body || '').slice(0, maxBodyLength);\n    const bodyWasTrimmed = (issueData.body || '').length > maxBodyLength;\n    const preferredModel = (issueData.body || '').length > 8000 ? 'gemini-2.5-pro' : undefined;\n\n    const projectStructure = await getProjectStructure();\n    \n    const historyContext = history.length > 0 \n      ? `\\nDialogue History:\\n${history.map(h => `[${h.role}] ${JSON.stringify(h.content)}`).join('\\n')}`\n      : '';\n\n    const prompt = `\n      Analyze the following GitHub issue and provide a structured JSON response.\n      ${historyContext}\n      \n      Issue Title: ${issueData.title}\n      Issue Body: ${trimmedBody}\n      ${bodyWasTrimmed ? 'Note: The body was truncated for performance. Prioritize key technical points.' : ''}\n      Labels: ${issueData.labels.join(', ')}\n\n      Current Project Structure:\n      ${projectStructure}\n      \n      Requirements:\n      1. Assess technical complexity (low, medium, high).\n      2. Classify the issue (bug, feature, question).\n      3. Suggest a Kanban column (${Object.values(KANBAN_COLUMNS).join(', ')}).\n      4. Generate at least 3 testable acceptance criteria.\n      5. Identify if any information is missing (true/false) and list what's missing.\n      6. Choose a representative emoji icon for the task.\n      7. Choose a representative hex color code for the task (e.g. #FF5733).\n      8. If the issue implies reading or modifying files to understand or fix it, specify \"fileActions\".\n         - Use \"read\" to request content of a file.\n         - Use \"write\" to create/overwrite a file.\n         - Use \"patch\" to replace a specific block of text in a file.\n      \n      Return JSON format:\n      {\n        \"complexity\": \"low|medium|high\",\n        \"type\": \"bug|feature|question\",\n        \"suggestedColumn\": \"...\",\n        \"acceptanceCriteria\": [\"...\", \"...\", \"...\"],\n        \"icon\": \"...\",\n        \"color\": \"#...\",\n        \"missingInformation\": {\n          \"isMissing\": false,\n          \"details\": []\n        },\n        \"fileActions\": [\n          {\n            \"action\": \"read|write|patch\",\n            \"path\": \"relative/path/to/file\",\n            \"content\": \"Full content for 'write' action\",\n            \"oldContent\": \"Exact block of text to find for 'patch' action\",\n            \"newContent\": \"Replacement text for 'patch' action\",\n            \"explanation\": \"Why this action is needed\"\n          }\n        ]\n      }\n    `;\n\n    const analysis = await this.client.generateJson(prompt, undefined, { preferredModel });\n    return analysis;\n  }\n\n  async generateClarificationDiscussion(issueData, missingDetails = []) {\n    if (!missingDetails.length) {\n      return {\n        summary: 'No blocking information is missing.',\n        questions: [],\n        requestedInputs: []\n      };\n    }\n\n    const prompt = `\n      You are preparing a follow-up discussion comment for a GitHub issue.\n\n      Issue title: ${issueData.title}\n      Issue body: ${(issueData.body || '').slice(0, 2000)}\n      Missing details identified by a previous analysis: ${missingDetails.join('; ')}\n\n      Produce a JSON response in French with:\n      - summary: one short sentence explaining why additional info is needed.\n      - questions: an array of 2 to 5 concrete clarification questions.\n      - requestedInputs: an array of concrete elements the user can provide (logs, reproduction steps, screenshots, design constraints, etc.).\n\n      Return JSON format:\n      {\n        \"summary\": \"...\",\n        \"questions\": [\"...\"],\n        \"requestedInputs\": [\"...\"]\n      }\n    `;\n\n    return this.client.generateJson(prompt);\n  }\n}\n"
        },
        {
          "path": "action.js",
          "content": "import * as core from '@actions/core';\nimport * as github from '@actions/github';\nimport { validateAndGetConfig } from './src/config/index.js';\nimport { GitHubClient } from './src/github/api-client.js';\nimport { GeminiClient } from './src/gemini/api-client.js';\nimport { IssueAnalyzer } from './src/gemini/analyzer.js';\nimport { BranchManager } from './src/github/branch-manager.js';\nimport { WorkflowManager } from './src/workflow/manager.js';\n\nasync function run() {\n  let config;\n  const CENTRAL_REPO = 'alphaleadership/kanbanaction';\n\n  try {\n    config = validateAndGetConfig();\n\n    if (config.debug) {\n        console.log('Debug mode enabled');\n        console.log('Context:', JSON.stringify(github.context, null, 2));\n    }\n\n    const githubClient = new GitHubClient(config.githubToken, config.githubRepo);\n\n    if (config.installWorkflows) {\n      const workflowInstaller = new WorkflowManager(githubClient, null, null, null);\n      await workflowInstaller.installWorkflows();\n      console.log('Workflow installation completed. Skipping event processing.');\n      return;\n    }\n\n    const geminiClient = new GeminiClient(config.geminiApiKey, {\n      primaryModel: config.geminiModel,\n      fallbackModels: config.geminiFallbackModels,\n      retries: config.geminiRetries\n    });\n    const analyzer = new IssueAnalyzer(geminiClient);\n    const branchManager = new BranchManager(githubClient);\n    const workflow = new WorkflowManager(githubClient, geminiClient, analyzer, branchManager);\n\n    const context = github.context;\n    \n    if (context.eventName === 'issues' && (context.payload.action === 'opened' || context.payload.action === 'labeled')) {\n      const issueNumber = context.payload.issue.number;\n      await workflow.processGitHubIssue(issueNumber);\n    } else if (context.eventName === 'pull_request' && context.payload.action === 'closed' && context.payload.pull_request.merged) {\n      const prNumber = context.payload.pull_request.number;\n      await workflow.processPullRequestMerge(prNumber);\n    } else if (context.eventName === 'workflow_dispatch' || context.eventName === 'schedule') {\n      console.log(`Triggered by ${context.eventName}. Processing pending tasks...`);\n      await workflow.processPendingTasks();\n    } else {\n      console.log(`Event ${context.eventName} with action ${context.payload.action} is not handled.`);\n    }\n\n      } catch (error) {\n        core.setFailed(error.message);\n        if (config?.debug) {\n          console.error('Detailed Error:', error);\n          console.error('Error Stack:', error.stack);\n        }\n    if (!config?.githubToken) {\n      console.error('Skipping centralized error report because no GitHub token is configured.');\n      return;\n    }\n    \n    try {\n      console.log(`Reporting error to central repository: ${CENTRAL_REPO}`);\n      const centralClient = new GitHubClient(config.githubToken, CENTRAL_REPO);\n      const errorTitle = `Error in ${github.context.payload.repository?.full_name || 'unknown repo'}: ${error.message.substring(0, 50)}...`;\n      const errorBody = `\n### Error Details\n- **Repository:** ${github.context.payload.repository?.full_name || 'Unknown'}\n- **Event:** ${github.context.eventName}\n- **Action:** ${github.context.payload.action || 'N/A'}\n- **Error Message:** ${error.message}\n\n### Stack Trace\n\\`\\`\\`\n${error.stack}\n\\`\\`\\`\n\n### Context\n<details>\n<summary>GitHub Context</summary>\n\n\\`\\`\\`json\n${JSON.stringify(github.context, null, 2)}\n\\`\\`\\`\n</details>\n      `;\n      \n      await centralClient.createIssue(errorTitle, errorBody, ['bug', 'automated-report']);\n    } catch (reportError) {\n      console.error('Failed to report error to central repository:', reportError.message);\n    }\n  }\n}\n\nrun();\n"
        },
        {
          "path": "src/workflow/manager.js",
          "content": "import fs from 'fs/promises';\nimport { delay } from '../utils/helpers.js';\nimport { extractIssueData, detectIssueType } from '../github/issue-processor.js';\nimport { createTask, addTaskToColumn, moveTask, getNextId } from '../kanban/task-manager.js';\nimport { readDb, writeDb } from '../kanban/file-operations.js';\nimport { DialogueManager } from '../gemini/dialogue-manager.js';\nimport { generateBranchName } from '../github/branch-manager.js';\nimport * as ConstantsModule from '../utils/constants.js';\n\nconst KANBAN_COLUMNS = ConstantsModule.KANBAN_COLUMNS;\nconst COLUMN_MAPPING = ConstantsModule.COLUMN_MAPPING;\n\nexport class WorkflowManager {\n  static KANBAN_COLUMNS = KANBAN_COLUMNS;\n  static COLUMN_MAPPING = COLUMN_MAPPING;\n\n  constructor(githubClient, geminiClient, analyzer, branchManager) {\n    this.githubClient = githubClient;\n    this.geminiClient = geminiClient;\n    this.analyzer = analyzer;\n    this.branchManager = branchManager;\n    this.dialogueManager = new DialogueManager();\n  }\n\n  async handleFileActions(actions, issueNumber, dialogue, branchName) {\n    if (!actions || !actions.length) return null;\n\n    let readResults = [];\n    const processedActions = [];\n\n    for (const action of actions) {\n      console.log(`Executing file action: ${action.action} on ${action.path}...`);\n      \n      try {\n        if (action.action === 'read') {\n          const content = await fs.readFile(action.path, 'utf8');\n          readResults.push({ path: action.path, content });\n          processedActions.push({ ...action, status: 'success' });\n        } else if (action.action === 'write') {\n          await fs.writeFile(action.path, action.content, 'utf8');\n          await this.githubClient.commitFile(action.path, action.content, `fix: automatic update via Gemini for #${issueNumber}\\n\\n${action.explanation}`, branchName);\n          processedActions.push({ ...action, status: 'success' });\n        } else if (action.action === 'patch') {\n          let content = await fs.readFile(action.path, 'utf8');\n          // Normalize line endings to LF for consistent matching\n          const normalizedContent = content.replace(/\\r\\n/g, '\\n');\n          const normalizedOld = action.oldContent.replace(/\\r\\n/g, '\\n');\n          const normalizedNew = action.newContent.replace(/\\r\\n/g, '\\n');\n\n          if (normalizedContent.includes(normalizedOld)) {\n            const updatedContent = normalizedContent.replace(normalizedOld, normalizedNew);\n            await fs.writeFile(action.path, updatedContent, 'utf8');\n            await this.githubClient.commitFile(action.path, updatedContent, `fix: patch applied via Gemini for #${issueNumber}\\n\\n${action.explanation}`, branchName);\n            processedActions.push({ ...action, status: 'success' });\n          } else {\n            throw new Error(`Could not find the exact 'oldContent' in ${action.path}. Please provide an exact match including indentation.`);\n          }\n        }\n      } catch (error) {\n        console.error(`Failed to execute action ${action.action} on ${action.path}:`, error.message);\n        processedActions.push({ ...action, status: 'error', error: error.message });\n      }\n    }\n\n    if (readResults.length > 0) {\n      this.dialogueManager.addEntry(dialogue, 'system', readResults, { type: 'file_read_results' });\n      await this.dialogueManager.saveDialogue(issueNumber, dialogue);\n      \n      console.log('Files read. Re-analyzing with new context...');\n      // Re-run analysis with context added to dialogue\n      // The analyzer will see the history in the dialogue if we pass it (to be implemented)\n      return await this.analyzer.analyzeIssue({\n          title: `Context Update #${issueNumber}`,\n          body: `I have read the requested files: ${readResults.map(r => r.path).join(', ')}. Please refine your analysis.`,\n          labels: []\n      }, dialogue.history);\n    }\n\n    return null;\n  }\n\n  async processGitHubIssue(issueNumber) {\n    console.log(`Processing issue #${issueNumber}...`);\n    \n    try {\n        // 1. Fetch issue\n        const rawIssue = await this.githubClient.getIssue(issueNumber);\n        const issueData = extractIssueData(rawIssue);\n\n        // Determine Task ID and Create Branch early\n        const db = await readDb();\n        const existingTaskEntry = Object.values(db).flat().find(t => t.metadata && t.metadata.issueNumber === issueNumber);\n        const taskId = existingTaskEntry ? existingTaskEntry.id : getNextId(db);\n        \n        console.log(`Creating/Ensuring branch for task #${taskId}...`);\n        const branchName = await this.branchManager.createBranchForTask(taskId, issueData.title);\n        console.log(`Using branch: ${branchName}`);\n\n        // Load dialogue context\n        let dialogue = await this.dialogueManager.loadDialogue(issueNumber);\n        this.dialogueManager.addEntry(dialogue, 'user', issueData, { event: 'issue_opened/labeled' });\n        \n        // 2. AI Analysis (with Loop for file actions)\n        let analysis;\n        let iterations = 0;\n        const maxIterations = 3;\n\n        while (iterations < maxIterations) {\n            console.log(`Analyzing issue with Gemini (Iteration ${iterations + 1})...`);\n            analysis = await this.analyzer.analyzeIssue(issueData, dialogue.history);\n            \n            // Save analysis to dialogue\n            this.dialogueManager.addEntry(dialogue, 'assistant', analysis, { type: 'analysis', iteration: iterations });\n            \n            if (analysis.fileActions && analysis.fileActions.length > 0) {\n                const nextAnalysis = await this.handleFileActions(analysis.fileActions, issueNumber, dialogue, branchName);\n                if (nextAnalysis) {\n                    iterations++;\n                    console.log('Waiting 2 seconds before next iteration...');\n                    await delay(2000);\n                    continue; \n                }\n            }\n            break;\n        }\n        \n        await this.dialogueManager.saveDialogue(issueNumber, dialogue);\n\n        // Commit dialogue file to repo on the dedicated branch\n        try {\n            const dialoguePath = this.dialogueManager.getRelativePath(issueNumber);\n            const dialogueContent = JSON.stringify(dialogue, null, 2);\n            await this.githubClient.commitFile(dialoguePath, dialogueContent, `docs: update dialogue context for #${issueNumber}`, branchName);\n        } catch (e) {\n            console.warn('Failed to commit dialogue file:', e.message);\n        }\n\n        // 3. Update Kanban\n        console.log('Updating Kanban board...');\n        const column = analysis.suggestedColumn || WorkflowManager.COLUMN_MAPPING[analysis.type] || 'idees';\n        \n        let task;\n        if (existingTaskEntry) {\n            console.log(`Task already exists for issue #${issueNumber}. Moving to ${column}...`);\n            task = existingTaskEntry;\n            task.icon = analysis.icon || task.icon;\n            task.color = analysis.color || task.color;\n            moveTask(db, task.id, column);\n        } else {\n            task = createTask(issueData.title, issueData.body, analysis.acceptanceCriteria, { issueNumber }, analysis.icon, analysis.color);\n            addTaskToColumn(db, task, column);\n        }\n                \n        await writeDb(db);\n        \n        // Commit changes to repository on the dedicated branch\n        console.log('Committing changes to repository...');\n        const dbContent = JSON.stringify(db, null, 2);\n        await this.githubClient.commitFile('.kaia', dbContent, `docs: update Kanban board - task ${task.id}`, branchName);\n        \n        // 4. GitHub Feedback\n        console.log('Adding comment and labels to GitHub...');\n        const missingDetails = analysis?.missingInformation?.details || [];\n        const isMissingInformation = Boolean(analysis?.missingInformation?.isMissing && missingDetails.length > 0);\n        const clarification = isMissingInformation\n          ? await this.analyzer.generateClarificationDiscussion(issueData, missingDetails)\n          : null;\n\n        const clarificationSummary = clarification?.summary\n          ? `\\n${clarification.summary}`\n          : '';\n        const clarificationQuestions = clarification?.questions?.length\n          ? `\\n\\n**Questions pour avancer :**\\n${clarification.questions.map(q => `- ${q}`).join('\\n')}`\n          : '';\n        const clarificationInputs = clarification?.requestedInputs?.length\n          ? `\\n\\n**Ã‰lÃ©ments Ã  fournir Ã  Gemini :**\\n${clarification.requestedInputs.map(i => `- ${i}`).join('\\n')}`\n          : '';\n\n        const commentBody = `\n### ${analysis.icon || 'ðŸ“'} Task Created: ${task.id}\n**Complexity:** ${analysis.complexity}\n**Type:** ${analysis.type}\n**Color:** \\`${analysis.color}\\`\n**Suggested Column:** ${column}\n\n#### Acceptance Criteria:\n${analysis.acceptanceCriteria.map(c => `- [ ] ${c}`).join('\\n')}\n\n${isMissingInformation ? `\\n> [!WARNING]\\n> **Missing Information:**\\n> ${missingDetails.join('\\n> ')}` : ''}\n${isMissingInformation ? `\\n\\n### ðŸ’¬ Discussion avec Gemini${clarificationSummary}${clarificationQuestions}${clarificationInputs}` : ''}\n    `;\n        \n        \n        try {\n            if (this.githubClient.debug) {\n                console.log('Attempting to create comment on GitHub issue...');\n            }\n            await this.githubClient.createComment(issueNumber, commentBody);\n            if (this.githubClient.debug) {\n                console.log('Successfully created comment on GitHub issue.');\n            }\n        } catch (commentError) {\n            console.error(`Error creating comment on issue #${issueNumber}:`, commentError.message);\n            if (this.githubClient.debug) {\n                console.error('Comment Error Stack:', commentError.stack);\n            }\n        }\n\n        try {\n            if (this.githubClient.debug) {\n                console.log('Attempting to add labels to GitHub issue...');\n            }\n            await this.githubClient.addLabels(issueNumber, [analysis.type, `complexity:${analysis.complexity}`]);\n            if (this.githubClient.debug) {\n                console.log('Successfully added labels to GitHub issue.');\n            }\n        } catch (labelError) {\n            console.error(`Error adding labels to issue #${issueNumber}:`, labelError.message);\n            if (this.githubClient.debug) {\n                console.error('Label Error Stack:', labelError.stack);\n            }\n        }\n        \n        await this.githubClient.addLabels(issueNumber, [analysis.type, `complexity:${analysis.complexity}`]);\n\n        // 5. PR Creation (if en_cours or file actions performed)\n        if (column === 'en_cours' || (analysis.fileActions && analysis.fileActions.length > 0)) {\n            console.log('Creating Pull Request...');\n            try {\n                await this.branchManager.createPRForTask(task.id, task.titre, branchName);\n            } catch (prError) {\n                console.error('Failed to create PR:', prError.message);\n            }\n        }\n\n        console.log(`Issue #${issueNumber} processed successfully. Task ID: ${task.id}`);\n        return task;\n    } catch (error) {\n        console.error(`Error processing issue #${issueNumber}:`, error.message);\n        try {\n            await this.githubClient.createComment(issueNumber, `âŒ **Error processing issue:** ${error.message}\\n\\nPlease check the action logs for more details.`);\n        } catch (e) {\n            console.error('Failed to post error comment to GitHub:', e.message);\n        }\n        throw error;\n    }\n  }\n\n  async processPendingTasks() {\n    console.log('Scanning Kanban for pending tasks...');\n    const db = await readDb();\n    const columnsToProcess = [WorkflowManager.KANBAN_COLUMNS.IDEES, WorkflowManager.KANBAN_COLUMNS.A_FAIRE];\n    let processedCount = 0;\n\n    for (const column of columnsToProcess) {\n      const tasks = db[column] || [];\n      for (const task of tasks) {\n        // Skip if already has an issue or was recently analyzed\n        if (task.metadata && task.metadata.issueNumber) continue;\n        \n        console.log(`Processing pending task #${task.id}: ${task.titre}...`);\n        \n        // Use AI to refine task\n        const analysis = await this.analyzer.analyzeIssue({\n          title: task.titre,\n          body: task.description || ''\n        });\n\n        // Update task with AI findings\n        task.description = task.description || '';\n        task.criteres_acceptation = analysis.acceptanceCriteria;\n        task.icon = analysis.icon || task.icon;\n        task.color = analysis.color || task.color;\n        task.metadata = {\n          ...task.metadata,\n          type: analysis.type,\n          complexity: analysis.complexity,\n          lastAnalyzed: new Date().toISOString()\n        };\n\n        processedCount++;\n        // Add a small delay between tasks to avoid 429\n        await delay(1000);\n      }\n    }\n\n    if (processedCount > 0) {\n      await writeDb(db);\n      const dbContent = JSON.stringify(db, null, 2);\n      await this.githubClient.commitFile('.kaia', dbContent, `docs: refine ${processedCount} pending tasks via Gemini`);\n      console.log(`Refined ${processedCount} tasks.`);\n    } else {\n      console.log('No pending tasks to process.');\n    }\n  }\n\n  async installWorkflows() {\n    const actionRepo = process.env.GITHUB_ACTION_REPOSITORY || 'alphaleadership/kanbanaction';\n    const actionVersion = actionRepo === 'alphaleadership/kanbanaction' ? 'master' : 'v1';\n\n    const sharedSteps = `\n      - uses: actions/checkout@v4\n      - name: Checkout action source\n        uses: actions/checkout@v4\n        with:\n          repository: ${actionRepo}\n          ref: ${actionVersion}\n          path: .kanban-action\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - name: Install action dependencies\n        run: npm ci\n        working-directory: .kanban-action\n      - name: Run Gemini Kanban Action\n        run: node action.js\n        working-directory: .kanban-action\n        env:\n          INPUT_GEMINI_API_KEY: \\${{ secrets.GEMINI_API_KEY }}\n          INPUT_GITHUB_TOKEN: \\${{ secrets.GH_PAT }}\n          GITHUB_TOKEN: \\${{ secrets.GH_PAT }}\n          GITHUB_REPOSITORY: \\${{ github.repository }}\n          GITHUB_REF: \\${{ github.ref }}\n          GITHUB_EVENT_NAME: \\${{ github.event_name }}\n          GITHUB_EVENT_PATH: \\${{ github.event_path }}\n          GITHUB_ACTION_REPOSITORY: ${actionRepo}\n`;\n\n    const workflows = [\n      {\n        path: '.github/workflows/gemini-kanban.yml',\n        content: `name: Gemini Kanban Integration\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [closed]\n  workflow_dispatch:\n\npermissions:\n  contents: write\n  issues: write\n  pull-requests: write\n\njobs:\n  process-issue:\n    runs-on: ubuntu-latest\n    steps:${sharedSteps}\n`\n      },\n      {\n        path: '.github/workflows/process-pending-tasks.yml',\n        content: `name: Process Pending Tasks\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\npermissions:\n  contents: write\n  issues: write\n  pull-requests: write\n\njobs:\n  process-tasks:\n    runs-on: ubuntu-latest\n    steps:${sharedSteps}\n`\n      },\n      {\n        path: '.github/workflows/test-and-report.yml',\n        content: `name: Run Tests and Report Failures\non:\n  workflow_dispatch:\n    inputs:\n      type:\n        description: 'Type of workflow run'\n        required: true\n        default: 'manual'\n        type: choice\n        options:\n          - manual\n          - scheduled\n          - CI\n  push:\n    branches: [ master,main ]\n  pull_request:\n    branches: [ master,main ]\n\npermissions:\n  contents: read\n  issues: write\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Checkout action source\n        uses: actions/checkout@v4\n        with:\n          repository: ${actionRepo}\n          ref: ${actionVersion}\n          path: .kanban-action\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - name: Install dependencies\n        run: npm ci\n      - name: Install action dependencies\n        run: npm ci\n        working-directory: .kanban-action\n      - name: Log Workflow Type\n        run: echo \"Running workflow of type \\${{ github.event.inputs.type || 'CI' }}\"\n      - name: Run Tests\n        run: npm test -- --json --outputFile=test-results.json || true\n      - name: Report Failures\n        if: always()\n        working-directory: .kanban-action\n        env:\n          GITHUB_TOKEN: \\${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}\n          GITHUB_REPOSITORY: \\${{ github.repository }}\n          TEST_RESULTS_PATH: ../test-results.json\n        run: node scripts/report-test-failures.mjs\n`\n      }\n    ];\n\n    console.log(`Installing/Updating workflows using action: ${actionRepo}@${actionVersion}...`);\n\n    for (const wf of workflows) {\n      try {\n        await this.githubClient.commitFile(wf.path, wf.content, `ci: install/update ${wf.path}`);\n        console.log(`Successfully installed ${wf.path}`);\n      } catch (error) {\n        let message = error.message;\n        if (error.status === 403 || error.status === 404) {\n          message += \" (Hint: The default GITHUB_TOKEN cannot modify workflow files. Ensure you are using a Personal Access Token (PAT) with 'workflow' scope.)\";\n        }\n        console.error(`Failed to install ${wf.path}:`, message);\n      }\n    }\n  }\n\n  async processPullRequestMerge(prNumber) {\n    console.log(`Processing merged PR #${prNumber}...`);\n\n    try {\n      // 1. Fetch PR data to find linked issues\n      const pr = await this.githubClient.octokit.pulls.get({\n        owner: this.githubClient.owner,\n        repo: this.githubClient.repo,\n        pull_number: prNumber\n      });\n\n      const body = pr.data.body || '';\n      // Simple regex to find \"closes #123\" or \"fixes #123\"\n      const issueMatches = body.match(/(?:closes|fixes|resolves)\\s+#(\\d+)/gi);\n\n      if (!issueMatches) {\n        console.log('No linked issues found in PR description.');\n        return;\n      }\n\n      const db = await readDb();\n      let updated = false;\n\n      for (const match of issueMatches) {\n        const issueNumber = parseInt(match.match(/\\d+/)[0]);\n        console.log(`Found linked issue #${issueNumber}. Moving task to 'termine'...`);\n\n        const existingTaskEntry = Object.values(db).flat().find(t => t.metadata && t.metadata.issueNumber === issueNumber);\n\n        if (existingTaskEntry) {\n          moveTask(db, existingTaskEntry.id, 'termine');\n          updated = true;\n          console.log(`Task #${existingTaskEntry.id} moved to 'termine'.`);\n        } else {\n          console.log(`No Kanban task found for issue #${issueNumber}.`);\n        }\n      }\n\n      if (updated) {\n        await writeDb(db);\n        const dbContent = JSON.stringify(db, null, 2);\n        await this.githubClient.commitFile('.kaia', dbContent, `docs: complete tasks from merged PR #${prNumber}`);\n      }\n    } catch (error) {\n      console.error(`Error processing merged PR #${prNumber}:`, error.message);\n      throw error;\n    }\n  }\n}"
        }
      ],
      "metadata": {
        "type": "file_read_results"
      }
    }
  ],
  "updated": "2026-02-17T13:23:41.788Z"
}