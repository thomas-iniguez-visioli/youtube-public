{
  "issueNumber": 50,
  "created": "2026-02-17T13:19:22.801Z",
  "history": [
    {
      "timestamp": "2026-02-17T13:19:22.801Z",
      "role": "user",
      "content": {
        "number": 50,
        "title": "Error: net::ERR_INSUFFICIENT_RESOURCES",
        "body": "View details in Rollbar: [https://app.rollbar.com/a/thomas.iniguez/fix/item/FirstProject/27](https://app.rollbar.com/a/thomas.iniguez/fix/item/FirstProject/27)\n\n```\n\nError: net::ERR_INSUFFICIENT_RESOURCES\n  File \"node:electron/js2c/browser_init\", line 2, in SimpleURLLoaderWrapper.<anonymous>\n  File \"node:events\", line 518, in SimpleURLLoaderWrapper.emit\n```",
        "labels": [],
        "author": "alphaleadership",
        "createdAt": "2026-02-17T13:19:04Z"
      },
      "metadata": {
        "event": "issue_opened/labeled"
      }
    },
    {
      "timestamp": "2026-02-17T13:19:35.221Z",
      "role": "assistant",
      "content": {
        "complexity": "medium",
        "type": "bug",
        "suggestedColumn": "a_faire",
        "acceptanceCriteria": [
          "The error `net::ERR_INSUFFICIENT_RESOURCES` no longer occurs under the conditions that previously triggered it.",
          "The application completes its intended operations without exhibiting signs of resource exhaustion (e.g., crashes, hangs, unexpected slowdowns).",
          "Network requests initiated by the application are handled robustly, ensuring stable resource consumption (e.g., memory, open connections) within expected operational limits."
        ],
        "icon": "ðŸš¨",
        "color": "#FF0000",
        "missingInformation": {
          "isMissing": true,
          "details": [
            "**Reproduction Steps**: Detailed instructions on how to reliably trigger this error, including any specific inputs or sequences of actions.",
            "**Application Context**: What specific operation or feature of the application (e.g., creating an issue, processing a pull request, running a test) was being performed when this error occurred?",
            "**Environment Details**: The operating system and specific version of Node.js/Electron (if applicable) where this error was observed. Clarification if this project is running as a GitHub Action or an Electron desktop application, as the stack trace (`node:electron/js2c/browser_init`) suggests an Electron context, which conflicts with the typical GitHub Action environment."
          ]
        },
        "fileActions": [
          {
            "action": "read",
            "path": "action.js",
            "explanation": "To understand the main entry point and overall flow of the GitHub Action, which might reveal where network requests are orchestrated or resource-intensive operations occur."
          },
          {
            "action": "read",
            "path": "src/github/api-client.js",
            "explanation": "To examine how API requests are made to GitHub, which could be a source of network resource consumption if not managed properly (e.g., too many concurrent requests)."
          },
          {
            "action": "read",
            "path": "src/gemini/analyzer.js",
            "explanation": "To check if any resource-intensive analysis or external calls are made that could lead to resource exhaustion."
          },
          {
            "action": "read",
            "path": "src/gemini/api-client.js",
            "explanation": "To examine how API requests are made to the Gemini service, similar to the GitHub API client, to identify potential resource bottlenecks."
          },
          {
            "action": "read",
            "path": "src/projects/api-client.js",
            "explanation": "To examine how API requests related to projects are made, as these could also contribute to resource usage."
          }
        ]
      },
      "metadata": {
        "type": "analysis",
        "iteration": 0
      }
    },
    {
      "timestamp": "2026-02-17T13:19:35.222Z",
      "role": "system",
      "content": [
        {
          "path": "action.js",
          "content": "import * as core from '@actions/core';\nimport * as github from '@actions/github';\nimport { validateAndGetConfig } from './src/config/index.js';\nimport { GitHubClient } from './src/github/api-client.js';\nimport { GeminiClient } from './src/gemini/api-client.js';\nimport { IssueAnalyzer } from './src/gemini/analyzer.js';\nimport { BranchManager } from './src/github/branch-manager.js';\nimport { WorkflowManager } from './src/workflow/manager.js';\n\nasync function run() {\n  let config;\n  const CENTRAL_REPO = 'alphaleadership/kanbanaction';\n\n  try {\n    config = validateAndGetConfig();\n\n    if (config.debug) {\n        console.log('Debug mode enabled');\n        console.log('Context:', JSON.stringify(github.context, null, 2));\n    }\n\n    const githubClient = new GitHubClient(config.githubToken, config.githubRepo);\n\n    if (config.installWorkflows) {\n      const workflowInstaller = new WorkflowManager(githubClient, null, null, null);\n      await workflowInstaller.installWorkflows();\n      console.log('Workflow installation completed. Skipping event processing.');\n      return;\n    }\n\n    const geminiClient = new GeminiClient(config.geminiApiKey, {\n      primaryModel: config.geminiModel,\n      fallbackModels: config.geminiFallbackModels,\n      retries: config.geminiRetries\n    });\n    const analyzer = new IssueAnalyzer(geminiClient);\n    const branchManager = new BranchManager(githubClient);\n    const workflow = new WorkflowManager(githubClient, geminiClient, analyzer, branchManager);\n\n    const context = github.context;\n    \n    if (context.eventName === 'issues' && (context.payload.action === 'opened' || context.payload.action === 'labeled')) {\n      const issueNumber = context.payload.issue.number;\n      await workflow.processGitHubIssue(issueNumber);\n    } else if (context.eventName === 'pull_request' && context.payload.action === 'closed' && context.payload.pull_request.merged) {\n      const prNumber = context.payload.pull_request.number;\n      await workflow.processPullRequestMerge(prNumber);\n    } else if (context.eventName === 'workflow_dispatch' || context.eventName === 'schedule') {\n      console.log(`Triggered by ${context.eventName}. Processing pending tasks...`);\n      await workflow.processPendingTasks();\n    } else {\n      console.log(`Event ${context.eventName} with action ${context.payload.action} is not handled.`);\n    }\n\n      } catch (error) {\n        core.setFailed(error.message);\n        if (config?.debug) {\n          console.error('Detailed Error:', error);\n          console.error('Error Stack:', error.stack);\n        }\n    if (!config?.githubToken) {\n      console.error('Skipping centralized error report because no GitHub token is configured.');\n      return;\n    }\n    \n    try {\n      console.log(`Reporting error to central repository: ${CENTRAL_REPO}`);\n      const centralClient = new GitHubClient(config.githubToken, CENTRAL_REPO);\n      const errorTitle = `Error in ${github.context.payload.repository?.full_name || 'unknown repo'}: ${error.message.substring(0, 50)}...`;\n      const errorBody = `\n### Error Details\n- **Repository:** ${github.context.payload.repository?.full_name || 'Unknown'}\n- **Event:** ${github.context.eventName}\n- **Action:** ${github.context.payload.action || 'N/A'}\n- **Error Message:** ${error.message}\n\n### Stack Trace\n\\`\\`\\`\n${error.stack}\n\\`\\`\\`\n\n### Context\n<details>\n<summary>GitHub Context</summary>\n\n\\`\\`\\`json\n${JSON.stringify(github.context, null, 2)}\n\\`\\`\\`\n</details>\n      `;\n      \n      await centralClient.createIssue(errorTitle, errorBody, ['bug', 'automated-report']);\n    } catch (reportError) {\n      console.error('Failed to report error to central repository:', reportError.message);\n    }\n  }\n}\n\nrun();\n"
        },
        {
          "path": "src/github/api-client.js",
          "content": "import { Octokit } from '@octokit/rest';\n\nexport class GitHubClient {\n  constructor(token, repoPath) {\n    this.octokit = new Octokit({ auth: token });\n    const [owner, repo] = repoPath.split('/');\n    this.owner = owner;\n    this.repo = repo;\n  }\n\n  async getIssue(issueNumber) {\n    const { data } = await this.octokit.issues.get({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber\n    });\n    return data;\n  }\n\n  async createComment(issueNumber, body) {\n    const { data } = await this.octokit.issues.createComment({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      body\n    });\n    return data;\n  }\n\n  async addLabels(issueNumber, labels) {\n    const { data } = await this.octokit.issues.addLabels({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      labels\n    });\n    return data;\n  }\n\n  async getRef(ref) {\n      const { data } = await this.octokit.git.getRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`\n      });\n      return data;\n  }\n\n  async createRef(ref, sha) {\n      const { data } = await this.octokit.git.createRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `refs/heads/${ref}`,\n          sha\n      });\n      return data;\n  }\n\n  async createCommit(message, tree, parents) {\n      const { data } = await this.octokit.git.createCommit({\n          owner: this.owner,\n          repo: this.repo,\n          message,\n          tree,\n          parents\n      });\n      return data;\n  }\n\n  async updateRef(ref, sha) {\n      await this.octokit.git.updateRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`,\n          sha\n      });\n  }\n\n  async getDefaultBranch() {\n    const { data } = await this.octokit.repos.get({\n      owner: this.owner,\n      repo: this.repo\n    });\n    return data.default_branch;\n  }\n\n  async createPullRequest(title, body, head, base) {\n    const { data } = await this.octokit.pulls.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      head,\n      base\n    });\n    return data;\n  }\n\n  async createIssue(title, body, labels = []) {\n    const { data } = await this.octokit.issues.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      labels\n    });\n    return data;\n  }\n\n  async getLatestCommitSha(branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const { data } = await this.octokit.repos.getBranch({\n          owner: this.owner,\n          repo: this.repo,\n          branch: targetBranch\n      });\n      return data.commit.sha;\n  }\n  \n  async commitFile(filePath, content, message, branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const sha = await this.getLatestCommitSha(targetBranch);\n      const { data: commit } = await this.octokit.git.getCommit({\n          owner: this.owner,\n          repo: this.repo,\n          commit_sha: sha\n      });\n      \n      const { data: blob } = await this.octokit.git.createBlob({\n          owner: this.owner,\n          repo: this.repo,\n          content,\n          encoding: 'utf-8'\n      });\n\n      const { data: tree } = await this.octokit.git.createTree({\n          owner: this.owner,\n          repo: this.repo,\n          base_tree: commit.tree.sha,\n          tree: [{\n              path: filePath,\n              mode: '100644',\n              type: 'blob',\n              sha: blob.sha\n          }]\n      });\n\n      const newCommit = await this.createCommit(message, tree.sha, [sha]);\n      await this.updateRef(targetBranch, newCommit.sha);\n      return newCommit;\n  }\n}\n"
        },
        {
          "path": "src/gemini/analyzer.js",
          "content": "import { KANBAN_COLUMNS } from '../utils/constants.js';\nimport { getProjectStructure } from '../utils/helpers.js';\n\nexport class IssueAnalyzer {\n  constructor(client) {\n    this.client = client;\n  }\n\n  async analyzeIssue(issueData, history = []) {\n    const maxBodyLength = 4000;\n    const trimmedBody = (issueData.body || '').slice(0, maxBodyLength);\n    const bodyWasTrimmed = (issueData.body || '').length > maxBodyLength;\n    const preferredModel = (issueData.body || '').length > 8000 ? 'gemini-2.5-pro' : undefined;\n\n    const projectStructure = await getProjectStructure();\n    \n    const historyContext = history.length > 0 \n      ? `\\nDialogue History:\\n${history.map(h => `[${h.role}] ${JSON.stringify(h.content)}`).join('\\n')}`\n      : '';\n\n    const prompt = `\n      Analyze the following GitHub issue and provide a structured JSON response.\n      ${historyContext}\n      \n      Issue Title: ${issueData.title}\n      Issue Body: ${trimmedBody}\n      ${bodyWasTrimmed ? 'Note: The body was truncated for performance. Prioritize key technical points.' : ''}\n      Labels: ${issueData.labels.join(', ')}\n\n      Current Project Structure:\n      ${projectStructure}\n      \n      Requirements:\n      1. Assess technical complexity (low, medium, high).\n      2. Classify the issue (bug, feature, question).\n      3. Suggest a Kanban column (${Object.values(KANBAN_COLUMNS).join(', ')}).\n      4. Generate at least 3 testable acceptance criteria.\n      5. Identify if any information is missing (true/false) and list what's missing.\n      6. Choose a representative emoji icon for the task.\n      7. Choose a representative hex color code for the task (e.g. #FF5733).\n      8. If the issue implies reading or modifying files to understand or fix it, specify \"fileActions\".\n         - Use \"read\" to request content of a file.\n         - Use \"write\" to create/overwrite a file.\n         - Use \"patch\" to replace a specific block of text in a file.\n      \n      Return JSON format:\n      {\n        \"complexity\": \"low|medium|high\",\n        \"type\": \"bug|feature|question\",\n        \"suggestedColumn\": \"...\",\n        \"acceptanceCriteria\": [\"...\", \"...\", \"...\"],\n        \"icon\": \"...\",\n        \"color\": \"#...\",\n        \"missingInformation\": {\n          \"isMissing\": false,\n          \"details\": []\n        },\n        \"fileActions\": [\n          {\n            \"action\": \"read|write|patch\",\n            \"path\": \"relative/path/to/file\",\n            \"content\": \"Full content for 'write' action\",\n            \"oldContent\": \"Exact block of text to find for 'patch' action\",\n            \"newContent\": \"Replacement text for 'patch' action\",\n            \"explanation\": \"Why this action is needed\"\n          }\n        ]\n      }\n    `;\n\n    const analysis = await this.client.generateJson(prompt, undefined, { preferredModel });\n    return analysis;\n  }\n\n  async generateClarificationDiscussion(issueData, missingDetails = []) {\n    if (!missingDetails.length) {\n      return {\n        summary: 'No blocking information is missing.',\n        questions: [],\n        requestedInputs: []\n      };\n    }\n\n    const prompt = `\n      You are preparing a follow-up discussion comment for a GitHub issue.\n\n      Issue title: ${issueData.title}\n      Issue body: ${(issueData.body || '').slice(0, 2000)}\n      Missing details identified by a previous analysis: ${missingDetails.join('; ')}\n\n      Produce a JSON response in French with:\n      - summary: one short sentence explaining why additional info is needed.\n      - questions: an array of 2 to 5 concrete clarification questions.\n      - requestedInputs: an array of concrete elements the user can provide (logs, reproduction steps, screenshots, design constraints, etc.).\n\n      Return JSON format:\n      {\n        \"summary\": \"...\",\n        \"questions\": [\"...\"],\n        \"requestedInputs\": [\"...\"]\n      }\n    `;\n\n    return this.client.generateJson(prompt);\n  }\n}\n"
        },
        {
          "path": "src/gemini/api-client.js",
          "content": "import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { delay as defaultDelay } from '../utils/helpers.js';\n\nexport class GeminiClient {\n  constructor(apiKey, modelOrOptions = 'gemini-2.5-flash', delayFn = defaultDelay) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.delay = delayFn;\n    const options = typeof modelOrOptions === 'string'\n      ? { primaryModel: modelOrOptions }\n      : (modelOrOptions || {});\n\n    this.primaryModel = options.primaryModel || 'gemini-2.5-flash';\n    this.fallbackModels = (options.fallbackModels || []).filter(Boolean);\n    this.retries = Number.isInteger(options.retries) && options.retries >= 0 ? options.retries : 3;\n    this.models = new Map();\n  }\n\n  getModel(modelName) {\n    if (!this.models.has(modelName)) {\n      this.models.set(modelName, this.genAI.getGenerativeModel({ model: modelName }));\n    }\n    return this.models.get(modelName);\n  }\n\n  getCandidateModels(preferredModel) {\n    const candidates = [preferredModel, this.primaryModel, ...this.fallbackModels].filter(Boolean);\n    return [...new Set(candidates)];\n  }\n\n  async generateContent(prompt, retries = this.retries, options = {}) {\n    let lastError;\n    const candidateModels = this.getCandidateModels(options.preferredModel);\n\n    for (let i = 0; i <= retries; i++) {\n      for (const modelName of candidateModels) {\n        try {\n          const model = this.getModel(modelName);\n          const result = await model.generateContent(prompt);\n          const response = await result.response;\n          return response.text();\n        } catch (error) {\n          lastError = error;\n        }\n      }\n\n      if (i < retries) {\n        const waitTime = Math.pow(2, i) * 2000; // Increased base from 1000 to 2000\n        console.log(`Rate limited or error occurred. Waiting ${waitTime}ms before retry ${i + 1}...`);\n        await this.delay(waitTime);\n      }\n    }\n\n    throw lastError;\n  }\n\n  async generateJson(prompt, retries = this.retries, options = {}) {\n      const jsonPrompt = `${prompt}\n\nIMPORTANT: Return ONLY valid JSON.`;\n      const text = await this.generateContent(jsonPrompt, retries, options);\n      try {\n          // Find JSON block if it exists\n          const jsonMatch = text.match(/\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]/);\n          const jsonStr = jsonMatch ? jsonMatch[0] : text;\n          return JSON.parse(jsonStr);\n      } catch (error) {\n          throw new Error(`Failed to parse Gemini response as JSON: ${error.message}\nResponse: ${text}`);\n      }\n  }\n}\n"
        },
        {
          "path": "src/projects/api-client.js",
          "content": "export class ProjectsClient {\n  constructor(octokit, org, projectNumber) {\n    this.octokit = octokit;\n    this.org = org;\n    this.projectNumber = projectNumber;\n    this.projectId = null;\n  }\n\n  async getProjectId() {\n    if (this.projectId) return this.projectId;\n\n    const query = `\n      query($org: String!, $number: Int!) {\n        organization(login: $org) {\n          projectV2(number: $number) {\n            id\n          }\n        }\n      }\n    `;\n\n    const response = await this.octokit.graphql(query, {\n      org: this.org,\n      number: this.projectNumber\n    });\n\n    this.projectId = response.organization.projectV2.id;\n    return this.projectId;\n  }\n\n  async addIssueToProject(issueId) {\n    const projectId = await this.getProjectId();\n    const query = `\n      mutation($projectId: ID!, $contentId: ID!) {\n        addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {\n          item {\n            id\n          }\n        }\n      }\n    `;\n\n    const response = await this.octokit.graphql(query, {\n      projectId,\n      contentId: issueId\n    });\n\n    return response.addProjectV2ItemById.item.id;\n  }\n\n  async updateItemStatus(itemId, statusFieldId, statusValueId) {\n      const projectId = await this.getProjectId();\n      const query = `\n        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {\n          updateProjectV2ItemFieldValue(input: {\n            projectId: $projectId,\n            itemId: $itemId,\n            fieldId: $fieldId,\n            value: { singleSelectOptionId: $value }\n          }) {\n            projectV2Item {\n              id\n            }\n          }\n        }\n      `;\n      // This is a simplified version. In reality, you need IDs for fields and options.\n  }\n}\n"
        }
      ],
      "metadata": {
        "type": "file_read_results"
      }
    },
    {
      "timestamp": "2026-02-17T13:20:06.185Z",
      "role": "assistant",
      "content": {
        "complexity": "medium",
        "type": "bug",
        "suggestedColumn": "a_faire",
        "acceptanceCriteria": [
          "The error `net::ERR_INSUFFICIENT_RESOURCES` no longer occurs under the conditions that previously triggered it.",
          "The application (whether GitHub Action or related Electron app) completes its intended operations without exhibiting signs of resource exhaustion (e.g., crashes, hangs, unexpected slowdowns).",
          "Network requests initiated by the application are handled robustly, ensuring stable resource consumption (e.g., memory, open connections) within expected operational limits."
        ],
        "icon": "ðŸš¨",
        "color": "#FF0000",
        "missingInformation": {
          "isMissing": true,
          "details": [
            "**Clarification on execution environment**: The error stack trace (`node:electron/js2c/browser_init`) strongly suggests an Electron application, which is highly unusual for a GitHub Action. Please confirm if this error occurred while running the GitHub Action in a standard GitHub Actions runner, or if it occurred in a separate Electron application that utilizes parts of this codebase or shares the Rollbar account.",
            "**Reproduction Steps**: Detailed instructions on how to reliably trigger this error, including any specific inputs or sequences of actions.",
            "**Application Context**: What specific operation or feature of the application (e.g., processing an issue, installing workflows, handling a PR merge, processing pending tasks, or a different Electron app feature) was being performed when this error occurred?"
          ]
        },
        "fileActions": [
          {
            "action": "read",
            "path": "action.js",
            "explanation": "To understand the main entry point and overall flow of the GitHub Action, identifying potential points where numerous or large network requests are initiated, or where resource-intensive operations are orchestrated."
          },
          {
            "action": "read",
            "path": "src/github/api-client.js",
            "explanation": "To examine how API requests are made to GitHub, as frequent or large requests via Octokit could contribute to network resource exhaustion. Check for potential unhandled concurrency or large data transfers."
          },
          {
            "action": "read",
            "path": "src/gemini/api-client.js",
            "explanation": "To examine how API requests are made to the Gemini service. The `generateContent` and `generateJson` methods, especially with retries and potentially large prompts, could be a source of resource consumption."
          },
          {
            "action": "read",
            "path": "src/gemini/analyzer.js",
            "explanation": "To review the `analyzeIssue` and `generateClarificationDiscussion` methods, which prepare and send prompts to the Gemini API. These prompts can be substantial and might contribute to resource usage during generation or transfer."
          },
          {
            "action": "read",
            "path": "src/projects/api-client.js",
            "explanation": "To examine GraphQL API requests related to GitHub Projects, as these are also network calls that could contribute to the overall resource load if not managed efficiently."
          }
        ]
      },
      "metadata": {
        "type": "analysis",
        "iteration": 1
      }
    },
    {
      "timestamp": "2026-02-17T13:20:06.187Z",
      "role": "system",
      "content": [
        {
          "path": "action.js",
          "content": "import * as core from '@actions/core';\nimport * as github from '@actions/github';\nimport { validateAndGetConfig } from './src/config/index.js';\nimport { GitHubClient } from './src/github/api-client.js';\nimport { GeminiClient } from './src/gemini/api-client.js';\nimport { IssueAnalyzer } from './src/gemini/analyzer.js';\nimport { BranchManager } from './src/github/branch-manager.js';\nimport { WorkflowManager } from './src/workflow/manager.js';\n\nasync function run() {\n  let config;\n  const CENTRAL_REPO = 'alphaleadership/kanbanaction';\n\n  try {\n    config = validateAndGetConfig();\n\n    if (config.debug) {\n        console.log('Debug mode enabled');\n        console.log('Context:', JSON.stringify(github.context, null, 2));\n    }\n\n    const githubClient = new GitHubClient(config.githubToken, config.githubRepo);\n\n    if (config.installWorkflows) {\n      const workflowInstaller = new WorkflowManager(githubClient, null, null, null);\n      await workflowInstaller.installWorkflows();\n      console.log('Workflow installation completed. Skipping event processing.');\n      return;\n    }\n\n    const geminiClient = new GeminiClient(config.geminiApiKey, {\n      primaryModel: config.geminiModel,\n      fallbackModels: config.geminiFallbackModels,\n      retries: config.geminiRetries\n    });\n    const analyzer = new IssueAnalyzer(geminiClient);\n    const branchManager = new BranchManager(githubClient);\n    const workflow = new WorkflowManager(githubClient, geminiClient, analyzer, branchManager);\n\n    const context = github.context;\n    \n    if (context.eventName === 'issues' && (context.payload.action === 'opened' || context.payload.action === 'labeled')) {\n      const issueNumber = context.payload.issue.number;\n      await workflow.processGitHubIssue(issueNumber);\n    } else if (context.eventName === 'pull_request' && context.payload.action === 'closed' && context.payload.pull_request.merged) {\n      const prNumber = context.payload.pull_request.number;\n      await workflow.processPullRequestMerge(prNumber);\n    } else if (context.eventName === 'workflow_dispatch' || context.eventName === 'schedule') {\n      console.log(`Triggered by ${context.eventName}. Processing pending tasks...`);\n      await workflow.processPendingTasks();\n    } else {\n      console.log(`Event ${context.eventName} with action ${context.payload.action} is not handled.`);\n    }\n\n      } catch (error) {\n        core.setFailed(error.message);\n        if (config?.debug) {\n          console.error('Detailed Error:', error);\n          console.error('Error Stack:', error.stack);\n        }\n    if (!config?.githubToken) {\n      console.error('Skipping centralized error report because no GitHub token is configured.');\n      return;\n    }\n    \n    try {\n      console.log(`Reporting error to central repository: ${CENTRAL_REPO}`);\n      const centralClient = new GitHubClient(config.githubToken, CENTRAL_REPO);\n      const errorTitle = `Error in ${github.context.payload.repository?.full_name || 'unknown repo'}: ${error.message.substring(0, 50)}...`;\n      const errorBody = `\n### Error Details\n- **Repository:** ${github.context.payload.repository?.full_name || 'Unknown'}\n- **Event:** ${github.context.eventName}\n- **Action:** ${github.context.payload.action || 'N/A'}\n- **Error Message:** ${error.message}\n\n### Stack Trace\n\\`\\`\\`\n${error.stack}\n\\`\\`\\`\n\n### Context\n<details>\n<summary>GitHub Context</summary>\n\n\\`\\`\\`json\n${JSON.stringify(github.context, null, 2)}\n\\`\\`\\`\n</details>\n      `;\n      \n      await centralClient.createIssue(errorTitle, errorBody, ['bug', 'automated-report']);\n    } catch (reportError) {\n      console.error('Failed to report error to central repository:', reportError.message);\n    }\n  }\n}\n\nrun();\n"
        },
        {
          "path": "src/github/api-client.js",
          "content": "import { Octokit } from '@octokit/rest';\n\nexport class GitHubClient {\n  constructor(token, repoPath) {\n    this.octokit = new Octokit({ auth: token });\n    const [owner, repo] = repoPath.split('/');\n    this.owner = owner;\n    this.repo = repo;\n  }\n\n  async getIssue(issueNumber) {\n    const { data } = await this.octokit.issues.get({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber\n    });\n    return data;\n  }\n\n  async createComment(issueNumber, body) {\n    const { data } = await this.octokit.issues.createComment({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      body\n    });\n    return data;\n  }\n\n  async addLabels(issueNumber, labels) {\n    const { data } = await this.octokit.issues.addLabels({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      labels\n    });\n    return data;\n  }\n\n  async getRef(ref) {\n      const { data } = await this.octokit.git.getRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`\n      });\n      return data;\n  }\n\n  async createRef(ref, sha) {\n      const { data } = await this.octokit.git.createRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `refs/heads/${ref}`,\n          sha\n      });\n      return data;\n  }\n\n  async createCommit(message, tree, parents) {\n      const { data } = await this.octokit.git.createCommit({\n          owner: this.owner,\n          repo: this.repo,\n          message,\n          tree,\n          parents\n      });\n      return data;\n  }\n\n  async updateRef(ref, sha) {\n      await this.octokit.git.updateRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`,\n          sha\n      });\n  }\n\n  async getDefaultBranch() {\n    const { data } = await this.octokit.repos.get({\n      owner: this.owner,\n      repo: this.repo\n    });\n    return data.default_branch;\n  }\n\n  async createPullRequest(title, body, head, base) {\n    const { data } = await this.octokit.pulls.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      head,\n      base\n    });\n    return data;\n  }\n\n  async createIssue(title, body, labels = []) {\n    const { data } = await this.octokit.issues.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      labels\n    });\n    return data;\n  }\n\n  async getLatestCommitSha(branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const { data } = await this.octokit.repos.getBranch({\n          owner: this.owner,\n          repo: this.repo,\n          branch: targetBranch\n      });\n      return data.commit.sha;\n  }\n  \n  async commitFile(filePath, content, message, branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const sha = await this.getLatestCommitSha(targetBranch);\n      const { data: commit } = await this.octokit.git.getCommit({\n          owner: this.owner,\n          repo: this.repo,\n          commit_sha: sha\n      });\n      \n      const { data: blob } = await this.octokit.git.createBlob({\n          owner: this.owner,\n          repo: this.repo,\n          content,\n          encoding: 'utf-8'\n      });\n\n      const { data: tree } = await this.octokit.git.createTree({\n          owner: this.owner,\n          repo: this.repo,\n          base_tree: commit.tree.sha,\n          tree: [{\n              path: filePath,\n              mode: '100644',\n              type: 'blob',\n              sha: blob.sha\n          }]\n      });\n\n      const newCommit = await this.createCommit(message, tree.sha, [sha]);\n      await this.updateRef(targetBranch, newCommit.sha);\n      return newCommit;\n  }\n}\n"
        },
        {
          "path": "src/gemini/api-client.js",
          "content": "import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { delay as defaultDelay } from '../utils/helpers.js';\n\nexport class GeminiClient {\n  constructor(apiKey, modelOrOptions = 'gemini-2.5-flash', delayFn = defaultDelay) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.delay = delayFn;\n    const options = typeof modelOrOptions === 'string'\n      ? { primaryModel: modelOrOptions }\n      : (modelOrOptions || {});\n\n    this.primaryModel = options.primaryModel || 'gemini-2.5-flash';\n    this.fallbackModels = (options.fallbackModels || []).filter(Boolean);\n    this.retries = Number.isInteger(options.retries) && options.retries >= 0 ? options.retries : 3;\n    this.models = new Map();\n  }\n\n  getModel(modelName) {\n    if (!this.models.has(modelName)) {\n      this.models.set(modelName, this.genAI.getGenerativeModel({ model: modelName }));\n    }\n    return this.models.get(modelName);\n  }\n\n  getCandidateModels(preferredModel) {\n    const candidates = [preferredModel, this.primaryModel, ...this.fallbackModels].filter(Boolean);\n    return [...new Set(candidates)];\n  }\n\n  async generateContent(prompt, retries = this.retries, options = {}) {\n    let lastError;\n    const candidateModels = this.getCandidateModels(options.preferredModel);\n\n    for (let i = 0; i <= retries; i++) {\n      for (const modelName of candidateModels) {\n        try {\n          const model = this.getModel(modelName);\n          const result = await model.generateContent(prompt);\n          const response = await result.response;\n          return response.text();\n        } catch (error) {\n          lastError = error;\n        }\n      }\n\n      if (i < retries) {\n        const waitTime = Math.pow(2, i) * 2000; // Increased base from 1000 to 2000\n        console.log(`Rate limited or error occurred. Waiting ${waitTime}ms before retry ${i + 1}...`);\n        await this.delay(waitTime);\n      }\n    }\n\n    throw lastError;\n  }\n\n  async generateJson(prompt, retries = this.retries, options = {}) {\n      const jsonPrompt = `${prompt}\n\nIMPORTANT: Return ONLY valid JSON.`;\n      const text = await this.generateContent(jsonPrompt, retries, options);\n      try {\n          // Find JSON block if it exists\n          const jsonMatch = text.match(/\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]/);\n          const jsonStr = jsonMatch ? jsonMatch[0] : text;\n          return JSON.parse(jsonStr);\n      } catch (error) {\n          throw new Error(`Failed to parse Gemini response as JSON: ${error.message}\nResponse: ${text}`);\n      }\n  }\n}\n"
        },
        {
          "path": "src/gemini/analyzer.js",
          "content": "import { KANBAN_COLUMNS } from '../utils/constants.js';\nimport { getProjectStructure } from '../utils/helpers.js';\n\nexport class IssueAnalyzer {\n  constructor(client) {\n    this.client = client;\n  }\n\n  async analyzeIssue(issueData, history = []) {\n    const maxBodyLength = 4000;\n    const trimmedBody = (issueData.body || '').slice(0, maxBodyLength);\n    const bodyWasTrimmed = (issueData.body || '').length > maxBodyLength;\n    const preferredModel = (issueData.body || '').length > 8000 ? 'gemini-2.5-pro' : undefined;\n\n    const projectStructure = await getProjectStructure();\n    \n    const historyContext = history.length > 0 \n      ? `\\nDialogue History:\\n${history.map(h => `[${h.role}] ${JSON.stringify(h.content)}`).join('\\n')}`\n      : '';\n\n    const prompt = `\n      Analyze the following GitHub issue and provide a structured JSON response.\n      ${historyContext}\n      \n      Issue Title: ${issueData.title}\n      Issue Body: ${trimmedBody}\n      ${bodyWasTrimmed ? 'Note: The body was truncated for performance. Prioritize key technical points.' : ''}\n      Labels: ${issueData.labels.join(', ')}\n\n      Current Project Structure:\n      ${projectStructure}\n      \n      Requirements:\n      1. Assess technical complexity (low, medium, high).\n      2. Classify the issue (bug, feature, question).\n      3. Suggest a Kanban column (${Object.values(KANBAN_COLUMNS).join(', ')}).\n      4. Generate at least 3 testable acceptance criteria.\n      5. Identify if any information is missing (true/false) and list what's missing.\n      6. Choose a representative emoji icon for the task.\n      7. Choose a representative hex color code for the task (e.g. #FF5733).\n      8. If the issue implies reading or modifying files to understand or fix it, specify \"fileActions\".\n         - Use \"read\" to request content of a file.\n         - Use \"write\" to create/overwrite a file.\n         - Use \"patch\" to replace a specific block of text in a file.\n      \n      Return JSON format:\n      {\n        \"complexity\": \"low|medium|high\",\n        \"type\": \"bug|feature|question\",\n        \"suggestedColumn\": \"...\",\n        \"acceptanceCriteria\": [\"...\", \"...\", \"...\"],\n        \"icon\": \"...\",\n        \"color\": \"#...\",\n        \"missingInformation\": {\n          \"isMissing\": false,\n          \"details\": []\n        },\n        \"fileActions\": [\n          {\n            \"action\": \"read|write|patch\",\n            \"path\": \"relative/path/to/file\",\n            \"content\": \"Full content for 'write' action\",\n            \"oldContent\": \"Exact block of text to find for 'patch' action\",\n            \"newContent\": \"Replacement text for 'patch' action\",\n            \"explanation\": \"Why this action is needed\"\n          }\n        ]\n      }\n    `;\n\n    const analysis = await this.client.generateJson(prompt, undefined, { preferredModel });\n    return analysis;\n  }\n\n  async generateClarificationDiscussion(issueData, missingDetails = []) {\n    if (!missingDetails.length) {\n      return {\n        summary: 'No blocking information is missing.',\n        questions: [],\n        requestedInputs: []\n      };\n    }\n\n    const prompt = `\n      You are preparing a follow-up discussion comment for a GitHub issue.\n\n      Issue title: ${issueData.title}\n      Issue body: ${(issueData.body || '').slice(0, 2000)}\n      Missing details identified by a previous analysis: ${missingDetails.join('; ')}\n\n      Produce a JSON response in French with:\n      - summary: one short sentence explaining why additional info is needed.\n      - questions: an array of 2 to 5 concrete clarification questions.\n      - requestedInputs: an array of concrete elements the user can provide (logs, reproduction steps, screenshots, design constraints, etc.).\n\n      Return JSON format:\n      {\n        \"summary\": \"...\",\n        \"questions\": [\"...\"],\n        \"requestedInputs\": [\"...\"]\n      }\n    `;\n\n    return this.client.generateJson(prompt);\n  }\n}\n"
        },
        {
          "path": "src/projects/api-client.js",
          "content": "export class ProjectsClient {\n  constructor(octokit, org, projectNumber) {\n    this.octokit = octokit;\n    this.org = org;\n    this.projectNumber = projectNumber;\n    this.projectId = null;\n  }\n\n  async getProjectId() {\n    if (this.projectId) return this.projectId;\n\n    const query = `\n      query($org: String!, $number: Int!) {\n        organization(login: $org) {\n          projectV2(number: $number) {\n            id\n          }\n        }\n      }\n    `;\n\n    const response = await this.octokit.graphql(query, {\n      org: this.org,\n      number: this.projectNumber\n    });\n\n    this.projectId = response.organization.projectV2.id;\n    return this.projectId;\n  }\n\n  async addIssueToProject(issueId) {\n    const projectId = await this.getProjectId();\n    const query = `\n      mutation($projectId: ID!, $contentId: ID!) {\n        addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {\n          item {\n            id\n          }\n        }\n      }\n    `;\n\n    const response = await this.octokit.graphql(query, {\n      projectId,\n      contentId: issueId\n    });\n\n    return response.addProjectV2ItemById.item.id;\n  }\n\n  async updateItemStatus(itemId, statusFieldId, statusValueId) {\n      const projectId = await this.getProjectId();\n      const query = `\n        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {\n          updateProjectV2ItemFieldValue(input: {\n            projectId: $projectId,\n            itemId: $itemId,\n            fieldId: $fieldId,\n            value: { singleSelectOptionId: $value }\n          }) {\n            projectV2Item {\n              id\n            }\n          }\n        }\n      `;\n      // This is a simplified version. In reality, you need IDs for fields and options.\n  }\n}\n"
        }
      ],
      "metadata": {
        "type": "file_read_results"
      }
    },
    {
      "timestamp": "2026-02-17T13:20:36.274Z",
      "role": "assistant",
      "content": {
        "complexity": "medium",
        "type": "bug",
        "suggestedColumn": "a_faire",
        "acceptanceCriteria": [
          "The error `net::ERR_INSUFFICIENT_RESOURCES` no longer occurs under the conditions that previously triggered it.",
          "The application (whether GitHub Action or related Electron app) completes its intended operations without exhibiting signs of resource exhaustion (e.g., crashes, hangs, unexpected slowdowns).",
          "Network requests initiated by the application are handled robustly, ensuring stable resource consumption (e.g., memory, open connections) within expected operational limits."
        ],
        "icon": "ðŸš¨",
        "color": "#FF0000",
        "missingInformation": {
          "isMissing": true,
          "details": [
            "**Clarification on execution environment**: The error stack trace (`node:electron/js2c/browser_init`) strongly suggests an Electron application, which is highly unusual for a GitHub Action. Please confirm if this error occurred while running the GitHub Action in a standard GitHub Actions runner, or if it occurred in a separate Electron application that utilizes parts of this codebase or shares the Rollbar account.",
            "**Reproduction Steps**: Detailed instructions on how to reliably trigger this error, including any specific inputs or sequences of actions.",
            "**Application Context**: What specific operation or feature of the application (e.g., processing an issue, installing workflows, handling a PR merge, processing pending tasks, or a different Electron app feature) was being performed when this error occurred?"
          ]
        },
        "fileActions": [
          {
            "action": "read",
            "path": "action.js",
            "explanation": "To understand the main entry point and overall flow of the GitHub Action, identifying potential points where numerous or large network requests are initiated, or where resource-intensive operations are orchestrated."
          },
          {
            "action": "read",
            "path": "src/github/api-client.js",
            "explanation": "To examine how API requests are made to GitHub, as frequent or large requests via Octokit could contribute to network resource exhaustion. Check for potential unhandled concurrency or large data transfers."
          },
          {
            "action": "read",
            "path": "src/gemini/api-client.js",
            "explanation": "To examine how API requests are made to the Gemini service. The `generateContent` and `generateJson` methods, especially with retries and potentially large prompts, could be a source of resource consumption."
          },
          {
            "action": "read",
            "path": "src/gemini/analyzer.js",
            "explanation": "To review the `analyzeIssue` and `generateClarificationDiscussion` methods, which prepare and send prompts to the Gemini API. These prompts can be substantial and might contribute to resource usage during generation or transfer."
          },
          {
            "action": "read",
            "path": "src/projects/api-client.js",
            "explanation": "To examine GraphQL API requests related to GitHub Projects, as these are also network calls that could contribute to the overall resource load if not managed efficiently."
          },
          {
            "action": "read",
            "path": "src/workflow/manager.js",
            "explanation": "To understand the high-level orchestration of different event types (issues, pull requests, pending tasks) and which specific sequence of operations might be leading to resource exhaustion."
          }
        ]
      },
      "metadata": {
        "type": "analysis",
        "iteration": 2
      }
    },
    {
      "timestamp": "2026-02-17T13:20:36.276Z",
      "role": "system",
      "content": [
        {
          "path": "action.js",
          "content": "import * as core from '@actions/core';\nimport * as github from '@actions/github';\nimport { validateAndGetConfig } from './src/config/index.js';\nimport { GitHubClient } from './src/github/api-client.js';\nimport { GeminiClient } from './src/gemini/api-client.js';\nimport { IssueAnalyzer } from './src/gemini/analyzer.js';\nimport { BranchManager } from './src/github/branch-manager.js';\nimport { WorkflowManager } from './src/workflow/manager.js';\n\nasync function run() {\n  let config;\n  const CENTRAL_REPO = 'alphaleadership/kanbanaction';\n\n  try {\n    config = validateAndGetConfig();\n\n    if (config.debug) {\n        console.log('Debug mode enabled');\n        console.log('Context:', JSON.stringify(github.context, null, 2));\n    }\n\n    const githubClient = new GitHubClient(config.githubToken, config.githubRepo);\n\n    if (config.installWorkflows) {\n      const workflowInstaller = new WorkflowManager(githubClient, null, null, null);\n      await workflowInstaller.installWorkflows();\n      console.log('Workflow installation completed. Skipping event processing.');\n      return;\n    }\n\n    const geminiClient = new GeminiClient(config.geminiApiKey, {\n      primaryModel: config.geminiModel,\n      fallbackModels: config.geminiFallbackModels,\n      retries: config.geminiRetries\n    });\n    const analyzer = new IssueAnalyzer(geminiClient);\n    const branchManager = new BranchManager(githubClient);\n    const workflow = new WorkflowManager(githubClient, geminiClient, analyzer, branchManager);\n\n    const context = github.context;\n    \n    if (context.eventName === 'issues' && (context.payload.action === 'opened' || context.payload.action === 'labeled')) {\n      const issueNumber = context.payload.issue.number;\n      await workflow.processGitHubIssue(issueNumber);\n    } else if (context.eventName === 'pull_request' && context.payload.action === 'closed' && context.payload.pull_request.merged) {\n      const prNumber = context.payload.pull_request.number;\n      await workflow.processPullRequestMerge(prNumber);\n    } else if (context.eventName === 'workflow_dispatch' || context.eventName === 'schedule') {\n      console.log(`Triggered by ${context.eventName}. Processing pending tasks...`);\n      await workflow.processPendingTasks();\n    } else {\n      console.log(`Event ${context.eventName} with action ${context.payload.action} is not handled.`);\n    }\n\n      } catch (error) {\n        core.setFailed(error.message);\n        if (config?.debug) {\n          console.error('Detailed Error:', error);\n          console.error('Error Stack:', error.stack);\n        }\n    if (!config?.githubToken) {\n      console.error('Skipping centralized error report because no GitHub token is configured.');\n      return;\n    }\n    \n    try {\n      console.log(`Reporting error to central repository: ${CENTRAL_REPO}`);\n      const centralClient = new GitHubClient(config.githubToken, CENTRAL_REPO);\n      const errorTitle = `Error in ${github.context.payload.repository?.full_name || 'unknown repo'}: ${error.message.substring(0, 50)}...`;\n      const errorBody = `\n### Error Details\n- **Repository:** ${github.context.payload.repository?.full_name || 'Unknown'}\n- **Event:** ${github.context.eventName}\n- **Action:** ${github.context.payload.action || 'N/A'}\n- **Error Message:** ${error.message}\n\n### Stack Trace\n\\`\\`\\`\n${error.stack}\n\\`\\`\\`\n\n### Context\n<details>\n<summary>GitHub Context</summary>\n\n\\`\\`\\`json\n${JSON.stringify(github.context, null, 2)}\n\\`\\`\\`\n</details>\n      `;\n      \n      await centralClient.createIssue(errorTitle, errorBody, ['bug', 'automated-report']);\n    } catch (reportError) {\n      console.error('Failed to report error to central repository:', reportError.message);\n    }\n  }\n}\n\nrun();\n"
        },
        {
          "path": "src/github/api-client.js",
          "content": "import { Octokit } from '@octokit/rest';\n\nexport class GitHubClient {\n  constructor(token, repoPath) {\n    this.octokit = new Octokit({ auth: token });\n    const [owner, repo] = repoPath.split('/');\n    this.owner = owner;\n    this.repo = repo;\n  }\n\n  async getIssue(issueNumber) {\n    const { data } = await this.octokit.issues.get({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber\n    });\n    return data;\n  }\n\n  async createComment(issueNumber, body) {\n    const { data } = await this.octokit.issues.createComment({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      body\n    });\n    return data;\n  }\n\n  async addLabels(issueNumber, labels) {\n    const { data } = await this.octokit.issues.addLabels({\n      owner: this.owner,\n      repo: this.repo,\n      issue_number: issueNumber,\n      labels\n    });\n    return data;\n  }\n\n  async getRef(ref) {\n      const { data } = await this.octokit.git.getRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`\n      });\n      return data;\n  }\n\n  async createRef(ref, sha) {\n      const { data } = await this.octokit.git.createRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `refs/heads/${ref}`,\n          sha\n      });\n      return data;\n  }\n\n  async createCommit(message, tree, parents) {\n      const { data } = await this.octokit.git.createCommit({\n          owner: this.owner,\n          repo: this.repo,\n          message,\n          tree,\n          parents\n      });\n      return data;\n  }\n\n  async updateRef(ref, sha) {\n      await this.octokit.git.updateRef({\n          owner: this.owner,\n          repo: this.repo,\n          ref: `heads/${ref}`,\n          sha\n      });\n  }\n\n  async getDefaultBranch() {\n    const { data } = await this.octokit.repos.get({\n      owner: this.owner,\n      repo: this.repo\n    });\n    return data.default_branch;\n  }\n\n  async createPullRequest(title, body, head, base) {\n    const { data } = await this.octokit.pulls.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      head,\n      base\n    });\n    return data;\n  }\n\n  async createIssue(title, body, labels = []) {\n    const { data } = await this.octokit.issues.create({\n      owner: this.owner,\n      repo: this.repo,\n      title,\n      body,\n      labels\n    });\n    return data;\n  }\n\n  async getLatestCommitSha(branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const { data } = await this.octokit.repos.getBranch({\n          owner: this.owner,\n          repo: this.repo,\n          branch: targetBranch\n      });\n      return data.commit.sha;\n  }\n  \n  async commitFile(filePath, content, message, branch) {\n      const targetBranch = branch || await this.getDefaultBranch();\n      const sha = await this.getLatestCommitSha(targetBranch);\n      const { data: commit } = await this.octokit.git.getCommit({\n          owner: this.owner,\n          repo: this.repo,\n          commit_sha: sha\n      });\n      \n      const { data: blob } = await this.octokit.git.createBlob({\n          owner: this.owner,\n          repo: this.repo,\n          content,\n          encoding: 'utf-8'\n      });\n\n      const { data: tree } = await this.octokit.git.createTree({\n          owner: this.owner,\n          repo: this.repo,\n          base_tree: commit.tree.sha,\n          tree: [{\n              path: filePath,\n              mode: '100644',\n              type: 'blob',\n              sha: blob.sha\n          }]\n      });\n\n      const newCommit = await this.createCommit(message, tree.sha, [sha]);\n      await this.updateRef(targetBranch, newCommit.sha);\n      return newCommit;\n  }\n}\n"
        },
        {
          "path": "src/gemini/api-client.js",
          "content": "import { GoogleGenerativeAI } from '@google/generative-ai';\nimport { delay as defaultDelay } from '../utils/helpers.js';\n\nexport class GeminiClient {\n  constructor(apiKey, modelOrOptions = 'gemini-2.5-flash', delayFn = defaultDelay) {\n    this.genAI = new GoogleGenerativeAI(apiKey);\n    this.delay = delayFn;\n    const options = typeof modelOrOptions === 'string'\n      ? { primaryModel: modelOrOptions }\n      : (modelOrOptions || {});\n\n    this.primaryModel = options.primaryModel || 'gemini-2.5-flash';\n    this.fallbackModels = (options.fallbackModels || []).filter(Boolean);\n    this.retries = Number.isInteger(options.retries) && options.retries >= 0 ? options.retries : 3;\n    this.models = new Map();\n  }\n\n  getModel(modelName) {\n    if (!this.models.has(modelName)) {\n      this.models.set(modelName, this.genAI.getGenerativeModel({ model: modelName }));\n    }\n    return this.models.get(modelName);\n  }\n\n  getCandidateModels(preferredModel) {\n    const candidates = [preferredModel, this.primaryModel, ...this.fallbackModels].filter(Boolean);\n    return [...new Set(candidates)];\n  }\n\n  async generateContent(prompt, retries = this.retries, options = {}) {\n    let lastError;\n    const candidateModels = this.getCandidateModels(options.preferredModel);\n\n    for (let i = 0; i <= retries; i++) {\n      for (const modelName of candidateModels) {\n        try {\n          const model = this.getModel(modelName);\n          const result = await model.generateContent(prompt);\n          const response = await result.response;\n          return response.text();\n        } catch (error) {\n          lastError = error;\n        }\n      }\n\n      if (i < retries) {\n        const waitTime = Math.pow(2, i) * 2000; // Increased base from 1000 to 2000\n        console.log(`Rate limited or error occurred. Waiting ${waitTime}ms before retry ${i + 1}...`);\n        await this.delay(waitTime);\n      }\n    }\n\n    throw lastError;\n  }\n\n  async generateJson(prompt, retries = this.retries, options = {}) {\n      const jsonPrompt = `${prompt}\n\nIMPORTANT: Return ONLY valid JSON.`;\n      const text = await this.generateContent(jsonPrompt, retries, options);\n      try {\n          // Find JSON block if it exists\n          const jsonMatch = text.match(/\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\]/);\n          const jsonStr = jsonMatch ? jsonMatch[0] : text;\n          return JSON.parse(jsonStr);\n      } catch (error) {\n          throw new Error(`Failed to parse Gemini response as JSON: ${error.message}\nResponse: ${text}`);\n      }\n  }\n}\n"
        },
        {
          "path": "src/gemini/analyzer.js",
          "content": "import { KANBAN_COLUMNS } from '../utils/constants.js';\nimport { getProjectStructure } from '../utils/helpers.js';\n\nexport class IssueAnalyzer {\n  constructor(client) {\n    this.client = client;\n  }\n\n  async analyzeIssue(issueData, history = []) {\n    const maxBodyLength = 4000;\n    const trimmedBody = (issueData.body || '').slice(0, maxBodyLength);\n    const bodyWasTrimmed = (issueData.body || '').length > maxBodyLength;\n    const preferredModel = (issueData.body || '').length > 8000 ? 'gemini-2.5-pro' : undefined;\n\n    const projectStructure = await getProjectStructure();\n    \n    const historyContext = history.length > 0 \n      ? `\\nDialogue History:\\n${history.map(h => `[${h.role}] ${JSON.stringify(h.content)}`).join('\\n')}`\n      : '';\n\n    const prompt = `\n      Analyze the following GitHub issue and provide a structured JSON response.\n      ${historyContext}\n      \n      Issue Title: ${issueData.title}\n      Issue Body: ${trimmedBody}\n      ${bodyWasTrimmed ? 'Note: The body was truncated for performance. Prioritize key technical points.' : ''}\n      Labels: ${issueData.labels.join(', ')}\n\n      Current Project Structure:\n      ${projectStructure}\n      \n      Requirements:\n      1. Assess technical complexity (low, medium, high).\n      2. Classify the issue (bug, feature, question).\n      3. Suggest a Kanban column (${Object.values(KANBAN_COLUMNS).join(', ')}).\n      4. Generate at least 3 testable acceptance criteria.\n      5. Identify if any information is missing (true/false) and list what's missing.\n      6. Choose a representative emoji icon for the task.\n      7. Choose a representative hex color code for the task (e.g. #FF5733).\n      8. If the issue implies reading or modifying files to understand or fix it, specify \"fileActions\".\n         - Use \"read\" to request content of a file.\n         - Use \"write\" to create/overwrite a file.\n         - Use \"patch\" to replace a specific block of text in a file.\n      \n      Return JSON format:\n      {\n        \"complexity\": \"low|medium|high\",\n        \"type\": \"bug|feature|question\",\n        \"suggestedColumn\": \"...\",\n        \"acceptanceCriteria\": [\"...\", \"...\", \"...\"],\n        \"icon\": \"...\",\n        \"color\": \"#...\",\n        \"missingInformation\": {\n          \"isMissing\": false,\n          \"details\": []\n        },\n        \"fileActions\": [\n          {\n            \"action\": \"read|write|patch\",\n            \"path\": \"relative/path/to/file\",\n            \"content\": \"Full content for 'write' action\",\n            \"oldContent\": \"Exact block of text to find for 'patch' action\",\n            \"newContent\": \"Replacement text for 'patch' action\",\n            \"explanation\": \"Why this action is needed\"\n          }\n        ]\n      }\n    `;\n\n    const analysis = await this.client.generateJson(prompt, undefined, { preferredModel });\n    return analysis;\n  }\n\n  async generateClarificationDiscussion(issueData, missingDetails = []) {\n    if (!missingDetails.length) {\n      return {\n        summary: 'No blocking information is missing.',\n        questions: [],\n        requestedInputs: []\n      };\n    }\n\n    const prompt = `\n      You are preparing a follow-up discussion comment for a GitHub issue.\n\n      Issue title: ${issueData.title}\n      Issue body: ${(issueData.body || '').slice(0, 2000)}\n      Missing details identified by a previous analysis: ${missingDetails.join('; ')}\n\n      Produce a JSON response in French with:\n      - summary: one short sentence explaining why additional info is needed.\n      - questions: an array of 2 to 5 concrete clarification questions.\n      - requestedInputs: an array of concrete elements the user can provide (logs, reproduction steps, screenshots, design constraints, etc.).\n\n      Return JSON format:\n      {\n        \"summary\": \"...\",\n        \"questions\": [\"...\"],\n        \"requestedInputs\": [\"...\"]\n      }\n    `;\n\n    return this.client.generateJson(prompt);\n  }\n}\n"
        },
        {
          "path": "src/projects/api-client.js",
          "content": "export class ProjectsClient {\n  constructor(octokit, org, projectNumber) {\n    this.octokit = octokit;\n    this.org = org;\n    this.projectNumber = projectNumber;\n    this.projectId = null;\n  }\n\n  async getProjectId() {\n    if (this.projectId) return this.projectId;\n\n    const query = `\n      query($org: String!, $number: Int!) {\n        organization(login: $org) {\n          projectV2(number: $number) {\n            id\n          }\n        }\n      }\n    `;\n\n    const response = await this.octokit.graphql(query, {\n      org: this.org,\n      number: this.projectNumber\n    });\n\n    this.projectId = response.organization.projectV2.id;\n    return this.projectId;\n  }\n\n  async addIssueToProject(issueId) {\n    const projectId = await this.getProjectId();\n    const query = `\n      mutation($projectId: ID!, $contentId: ID!) {\n        addProjectV2ItemById(input: {projectId: $projectId, contentId: $contentId}) {\n          item {\n            id\n          }\n        }\n      }\n    `;\n\n    const response = await this.octokit.graphql(query, {\n      projectId,\n      contentId: issueId\n    });\n\n    return response.addProjectV2ItemById.item.id;\n  }\n\n  async updateItemStatus(itemId, statusFieldId, statusValueId) {\n      const projectId = await this.getProjectId();\n      const query = `\n        mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $value: String!) {\n          updateProjectV2ItemFieldValue(input: {\n            projectId: $projectId,\n            itemId: $itemId,\n            fieldId: $fieldId,\n            value: { singleSelectOptionId: $value }\n          }) {\n            projectV2Item {\n              id\n            }\n          }\n        }\n      `;\n      // This is a simplified version. In reality, you need IDs for fields and options.\n  }\n}\n"
        },
        {
          "path": "src/workflow/manager.js",
          "content": "import fs from 'fs/promises';\nimport { delay } from '../utils/helpers.js';\nimport { extractIssueData, detectIssueType } from '../github/issue-processor.js';\nimport { createTask, addTaskToColumn, moveTask, getNextId } from '../kanban/task-manager.js';\nimport { readDb, writeDb } from '../kanban/file-operations.js';\nimport { DialogueManager } from '../gemini/dialogue-manager.js';\nimport { generateBranchName } from '../github/branch-manager.js';\nimport * as ConstantsModule from '../utils/constants.js';\n\nconst KANBAN_COLUMNS = ConstantsModule.KANBAN_COLUMNS;\nconst COLUMN_MAPPING = ConstantsModule.COLUMN_MAPPING;\n\nexport class WorkflowManager {\n  static KANBAN_COLUMNS = KANBAN_COLUMNS;\n  static COLUMN_MAPPING = COLUMN_MAPPING;\n\n  constructor(githubClient, geminiClient, analyzer, branchManager) {\n    this.githubClient = githubClient;\n    this.geminiClient = geminiClient;\n    this.analyzer = analyzer;\n    this.branchManager = branchManager;\n    this.dialogueManager = new DialogueManager();\n  }\n\n  async handleFileActions(actions, issueNumber, dialogue, branchName) {\n    if (!actions || !actions.length) return null;\n\n    let readResults = [];\n    const processedActions = [];\n\n    for (const action of actions) {\n      console.log(`Executing file action: ${action.action} on ${action.path}...`);\n      \n      try {\n        if (action.action === 'read') {\n          const content = await fs.readFile(action.path, 'utf8');\n          readResults.push({ path: action.path, content });\n          processedActions.push({ ...action, status: 'success' });\n        } else if (action.action === 'write') {\n          await fs.writeFile(action.path, action.content, 'utf8');\n          await this.githubClient.commitFile(action.path, action.content, `fix: automatic update via Gemini for #${issueNumber}\\n\\n${action.explanation}`, branchName);\n          processedActions.push({ ...action, status: 'success' });\n        } else if (action.action === 'patch') {\n          let content = await fs.readFile(action.path, 'utf8');\n          // Normalize line endings to LF for consistent matching\n          const normalizedContent = content.replace(/\\r\\n/g, '\\n');\n          const normalizedOld = action.oldContent.replace(/\\r\\n/g, '\\n');\n          const normalizedNew = action.newContent.replace(/\\r\\n/g, '\\n');\n\n          if (normalizedContent.includes(normalizedOld)) {\n            const updatedContent = normalizedContent.replace(normalizedOld, normalizedNew);\n            await fs.writeFile(action.path, updatedContent, 'utf8');\n            await this.githubClient.commitFile(action.path, updatedContent, `fix: patch applied via Gemini for #${issueNumber}\\n\\n${action.explanation}`, branchName);\n            processedActions.push({ ...action, status: 'success' });\n          } else {\n            throw new Error(`Could not find the exact 'oldContent' in ${action.path}. Please provide an exact match including indentation.`);\n          }\n        }\n      } catch (error) {\n        console.error(`Failed to execute action ${action.action} on ${action.path}:`, error.message);\n        processedActions.push({ ...action, status: 'error', error: error.message });\n      }\n    }\n\n    if (readResults.length > 0) {\n      this.dialogueManager.addEntry(dialogue, 'system', readResults, { type: 'file_read_results' });\n      await this.dialogueManager.saveDialogue(issueNumber, dialogue);\n      \n      console.log('Files read. Re-analyzing with new context...');\n      // Re-run analysis with context added to dialogue\n      // The analyzer will see the history in the dialogue if we pass it (to be implemented)\n      return await this.analyzer.analyzeIssue({\n          title: `Context Update #${issueNumber}`,\n          body: `I have read the requested files: ${readResults.map(r => r.path).join(', ')}. Please refine your analysis.`,\n          labels: []\n      }, dialogue.history);\n    }\n\n    return null;\n  }\n\n  async processGitHubIssue(issueNumber) {\n    console.log(`Processing issue #${issueNumber}...`);\n    \n    try {\n        // 1. Fetch issue\n        const rawIssue = await this.githubClient.getIssue(issueNumber);\n        const issueData = extractIssueData(rawIssue);\n\n        // Determine Task ID and Create Branch early\n        const db = await readDb();\n        const existingTaskEntry = Object.values(db).flat().find(t => t.metadata && t.metadata.issueNumber === issueNumber);\n        const taskId = existingTaskEntry ? existingTaskEntry.id : getNextId(db);\n        \n        console.log(`Creating/Ensuring branch for task #${taskId}...`);\n        const branchName = await this.branchManager.createBranchForTask(taskId, issueData.title);\n        console.log(`Using branch: ${branchName}`);\n\n        // Load dialogue context\n        let dialogue = await this.dialogueManager.loadDialogue(issueNumber);\n        this.dialogueManager.addEntry(dialogue, 'user', issueData, { event: 'issue_opened/labeled' });\n        \n        // 2. AI Analysis (with Loop for file actions)\n        let analysis;\n        let iterations = 0;\n        const maxIterations = 3;\n\n        while (iterations < maxIterations) {\n            console.log(`Analyzing issue with Gemini (Iteration ${iterations + 1})...`);\n            analysis = await this.analyzer.analyzeIssue(issueData, dialogue.history);\n            \n            // Save analysis to dialogue\n            this.dialogueManager.addEntry(dialogue, 'assistant', analysis, { type: 'analysis', iteration: iterations });\n            \n            if (analysis.fileActions && analysis.fileActions.length > 0) {\n                const nextAnalysis = await this.handleFileActions(analysis.fileActions, issueNumber, dialogue, branchName);\n                if (nextAnalysis) {\n                    iterations++;\n                    console.log('Waiting 2 seconds before next iteration...');\n                    await delay(2000);\n                    continue; \n                }\n            }\n            break;\n        }\n        \n        await this.dialogueManager.saveDialogue(issueNumber, dialogue);\n\n        // Commit dialogue file to repo on the dedicated branch\n        try {\n            const dialoguePath = this.dialogueManager.getRelativePath(issueNumber);\n            const dialogueContent = JSON.stringify(dialogue, null, 2);\n            await this.githubClient.commitFile(dialoguePath, dialogueContent, `docs: update dialogue context for #${issueNumber}`, branchName);\n        } catch (e) {\n            console.warn('Failed to commit dialogue file:', e.message);\n        }\n\n        // 3. Update Kanban\n        console.log('Updating Kanban board...');\n        const column = analysis.suggestedColumn || WorkflowManager.COLUMN_MAPPING[analysis.type] || 'idees';\n        \n        let task;\n        if (existingTaskEntry) {\n            console.log(`Task already exists for issue #${issueNumber}. Moving to ${column}...`);\n            task = existingTaskEntry;\n            task.icon = analysis.icon || task.icon;\n            task.color = analysis.color || task.color;\n            moveTask(db, task.id, column);\n        } else {\n            task = createTask(issueData.title, issueData.body, analysis.acceptanceCriteria, { issueNumber }, analysis.icon, analysis.color);\n            addTaskToColumn(db, task, column);\n        }\n                \n        await writeDb(db);\n        \n        // Commit changes to repository on the dedicated branch\n        console.log('Committing changes to repository...');\n        const dbContent = JSON.stringify(db, null, 2);\n        await this.githubClient.commitFile('.kaia', dbContent, `docs: update Kanban board - task ${task.id}`, branchName);\n        \n        // 4. GitHub Feedback\n        console.log('Adding comment and labels to GitHub...');\n        const missingDetails = analysis?.missingInformation?.details || [];\n        const isMissingInformation = Boolean(analysis?.missingInformation?.isMissing && missingDetails.length > 0);\n        const clarification = isMissingInformation\n          ? await this.analyzer.generateClarificationDiscussion(issueData, missingDetails)\n          : null;\n\n        const clarificationSummary = clarification?.summary\n          ? `\\n${clarification.summary}`\n          : '';\n        const clarificationQuestions = clarification?.questions?.length\n          ? `\\n\\n**Questions pour avancer :**\\n${clarification.questions.map(q => `- ${q}`).join('\\n')}`\n          : '';\n        const clarificationInputs = clarification?.requestedInputs?.length\n          ? `\\n\\n**Ã‰lÃ©ments Ã  fournir Ã  Gemini :**\\n${clarification.requestedInputs.map(i => `- ${i}`).join('\\n')}`\n          : '';\n\n        const commentBody = `\n### ${analysis.icon || 'ðŸ“'} Task Created: ${task.id}\n**Complexity:** ${analysis.complexity}\n**Type:** ${analysis.type}\n**Color:** \\`${analysis.color}\\`\n**Suggested Column:** ${column}\n\n#### Acceptance Criteria:\n${analysis.acceptanceCriteria.map(c => `- [ ] ${c}`).join('\\n')}\n\n${isMissingInformation ? `\\n> [!WARNING]\\n> **Missing Information:**\\n> ${missingDetails.join('\\n> ')}` : ''}\n${isMissingInformation ? `\\n\\n### ðŸ’¬ Discussion avec Gemini${clarificationSummary}${clarificationQuestions}${clarificationInputs}` : ''}\n    `;\n        \n        \n        try {\n            if (this.githubClient.debug) {\n                console.log('Attempting to create comment on GitHub issue...');\n            }\n            await this.githubClient.createComment(issueNumber, commentBody);\n            if (this.githubClient.debug) {\n                console.log('Successfully created comment on GitHub issue.');\n            }\n        } catch (commentError) {\n            console.error(`Error creating comment on issue #${issueNumber}:`, commentError.message);\n            if (this.githubClient.debug) {\n                console.error('Comment Error Stack:', commentError.stack);\n            }\n        }\n\n        try {\n            if (this.githubClient.debug) {\n                console.log('Attempting to add labels to GitHub issue...');\n            }\n            await this.githubClient.addLabels(issueNumber, [analysis.type, `complexity:${analysis.complexity}`]);\n            if (this.githubClient.debug) {\n                console.log('Successfully added labels to GitHub issue.');\n            }\n        } catch (labelError) {\n            console.error(`Error adding labels to issue #${issueNumber}:`, labelError.message);\n            if (this.githubClient.debug) {\n                console.error('Label Error Stack:', labelError.stack);\n            }\n        }\n        \n        await this.githubClient.addLabels(issueNumber, [analysis.type, `complexity:${analysis.complexity}`]);\n\n        // 5. PR Creation (if en_cours or file actions performed)\n        if (column === 'en_cours' || (analysis.fileActions && analysis.fileActions.length > 0)) {\n            console.log('Creating Pull Request...');\n            try {\n                await this.branchManager.createPRForTask(task.id, task.titre, branchName);\n            } catch (prError) {\n                console.error('Failed to create PR:', prError.message);\n            }\n        }\n\n        console.log(`Issue #${issueNumber} processed successfully. Task ID: ${task.id}`);\n        return task;\n    } catch (error) {\n        console.error(`Error processing issue #${issueNumber}:`, error.message);\n        try {\n            await this.githubClient.createComment(issueNumber, `âŒ **Error processing issue:** ${error.message}\\n\\nPlease check the action logs for more details.`);\n        } catch (e) {\n            console.error('Failed to post error comment to GitHub:', e.message);\n        }\n        throw error;\n    }\n  }\n\n  async processPendingTasks() {\n    console.log('Scanning Kanban for pending tasks...');\n    const db = await readDb();\n    const columnsToProcess = [WorkflowManager.KANBAN_COLUMNS.IDEES, WorkflowManager.KANBAN_COLUMNS.A_FAIRE];\n    let processedCount = 0;\n\n    for (const column of columnsToProcess) {\n      const tasks = db[column] || [];\n      for (const task of tasks) {\n        // Skip if already has an issue or was recently analyzed\n        if (task.metadata && task.metadata.issueNumber) continue;\n        \n        console.log(`Processing pending task #${task.id}: ${task.titre}...`);\n        \n        // Use AI to refine task\n        const analysis = await this.analyzer.analyzeIssue({\n          title: task.titre,\n          body: task.description || ''\n        });\n\n        // Update task with AI findings\n        task.description = task.description || '';\n        task.criteres_acceptation = analysis.acceptanceCriteria;\n        task.icon = analysis.icon || task.icon;\n        task.color = analysis.color || task.color;\n        task.metadata = {\n          ...task.metadata,\n          type: analysis.type,\n          complexity: analysis.complexity,\n          lastAnalyzed: new Date().toISOString()\n        };\n\n        processedCount++;\n        // Add a small delay between tasks to avoid 429\n        await delay(1000);\n      }\n    }\n\n    if (processedCount > 0) {\n      await writeDb(db);\n      const dbContent = JSON.stringify(db, null, 2);\n      await this.githubClient.commitFile('.kaia', dbContent, `docs: refine ${processedCount} pending tasks via Gemini`);\n      console.log(`Refined ${processedCount} tasks.`);\n    } else {\n      console.log('No pending tasks to process.');\n    }\n  }\n\n  async installWorkflows() {\n    const actionRepo = process.env.GITHUB_ACTION_REPOSITORY || 'alphaleadership/kanbanaction';\n    const actionVersion = actionRepo === 'alphaleadership/kanbanaction' ? 'master' : 'v1';\n\n    const sharedSteps = `\n      - uses: actions/checkout@v4\n      - name: Checkout action source\n        uses: actions/checkout@v4\n        with:\n          repository: ${actionRepo}\n          ref: ${actionVersion}\n          path: .kanban-action\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n      - name: Install action dependencies\n        run: npm ci\n        working-directory: .kanban-action\n      - name: Run Gemini Kanban Action\n        run: node action.js\n        working-directory: .kanban-action\n        env:\n          INPUT_GEMINI_API_KEY: \\${{ secrets.GEMINI_API_KEY }}\n          INPUT_GITHUB_TOKEN: \\${{ secrets.GH_PAT }}\n          GITHUB_TOKEN: \\${{ secrets.GH_PAT }}\n          GITHUB_REPOSITORY: \\${{ github.repository }}\n          GITHUB_REF: \\${{ github.ref }}\n          GITHUB_EVENT_NAME: \\${{ github.event_name }}\n          GITHUB_EVENT_PATH: \\${{ github.event_path }}\n          GITHUB_ACTION_REPOSITORY: ${actionRepo}\n`;\n\n    const workflows = [\n      {\n        path: '.github/workflows/gemini-kanban.yml',\n        content: `name: Gemini Kanban Integration\non:\n  issues:\n    types: [opened, labeled]\n  pull_request:\n    types: [closed]\n  workflow_dispatch:\n\npermissions:\n  contents: write\n  issues: write\n  pull-requests: write\n\njobs:\n  process-issue:\n    runs-on: ubuntu-latest\n    steps:${sharedSteps}\n`\n      },\n      {\n        path: '.github/workflows/process-pending-tasks.yml',\n        content: `name: Process Pending Tasks\non:\n  schedule:\n    - cron: '0 0 * * *'\n  workflow_dispatch:\n\npermissions:\n  contents: write\n  issues: write\n  pull-requests: write\n\njobs:\n  process-tasks:\n    runs-on: ubuntu-latest\n    steps:${sharedSteps}\n`\n      },\n      {\n        path: '.github/workflows/test-and-report.yml',\n        content: `name: Run Tests and Report Failures\non:\n  workflow_dispatch:\n    inputs:\n      type:\n        description: 'Type of workflow run'\n        required: true\n        default: 'manual'\n        type: choice\n        options:\n          - manual\n          - scheduled\n          - CI\n  push:\n    branches: [ master,main ]\n  pull_request:\n    branches: [ master,main ]\n\npermissions:\n  contents: read\n  issues: write\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Checkout action source\n        uses: actions/checkout@v4\n        with:\n          repository: ${actionRepo}\n          ref: ${actionVersion}\n          path: .kanban-action\n      - name: Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: '20'\n          cache: 'npm'\n      - name: Install dependencies\n        run: npm ci\n      - name: Install action dependencies\n        run: npm ci\n        working-directory: .kanban-action\n      - name: Log Workflow Type\n        run: echo \"Running workflow of type \\${{ github.event.inputs.type || 'CI' }}\"\n      - name: Run Tests\n        run: npm test -- --json --outputFile=test-results.json || true\n      - name: Report Failures\n        if: always()\n        working-directory: .kanban-action\n        env:\n          GITHUB_TOKEN: \\${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}\n          GITHUB_REPOSITORY: \\${{ github.repository }}\n          TEST_RESULTS_PATH: ../test-results.json\n        run: node scripts/report-test-failures.mjs\n`\n      }\n    ];\n\n    console.log(`Installing/Updating workflows using action: ${actionRepo}@${actionVersion}...`);\n\n    for (const wf of workflows) {\n      try {\n        await this.githubClient.commitFile(wf.path, wf.content, `ci: install/update ${wf.path}`);\n        console.log(`Successfully installed ${wf.path}`);\n      } catch (error) {\n        let message = error.message;\n        if (error.status === 403 || error.status === 404) {\n          message += \" (Hint: The default GITHUB_TOKEN cannot modify workflow files. Ensure you are using a Personal Access Token (PAT) with 'workflow' scope.)\";\n        }\n        console.error(`Failed to install ${wf.path}:`, message);\n      }\n    }\n  }\n\n  async processPullRequestMerge(prNumber) {\n    console.log(`Processing merged PR #${prNumber}...`);\n\n    try {\n      // 1. Fetch PR data to find linked issues\n      const pr = await this.githubClient.octokit.pulls.get({\n        owner: this.githubClient.owner,\n        repo: this.githubClient.repo,\n        pull_number: prNumber\n      });\n\n      const body = pr.data.body || '';\n      // Simple regex to find \"closes #123\" or \"fixes #123\"\n      const issueMatches = body.match(/(?:closes|fixes|resolves)\\s+#(\\d+)/gi);\n\n      if (!issueMatches) {\n        console.log('No linked issues found in PR description.');\n        return;\n      }\n\n      const db = await readDb();\n      let updated = false;\n\n      for (const match of issueMatches) {\n        const issueNumber = parseInt(match.match(/\\d+/)[0]);\n        console.log(`Found linked issue #${issueNumber}. Moving task to 'termine'...`);\n\n        const existingTaskEntry = Object.values(db).flat().find(t => t.metadata && t.metadata.issueNumber === issueNumber);\n\n        if (existingTaskEntry) {\n          moveTask(db, existingTaskEntry.id, 'termine');\n          updated = true;\n          console.log(`Task #${existingTaskEntry.id} moved to 'termine'.`);\n        } else {\n          console.log(`No Kanban task found for issue #${issueNumber}.`);\n        }\n      }\n\n      if (updated) {\n        await writeDb(db);\n        const dbContent = JSON.stringify(db, null, 2);\n        await this.githubClient.commitFile('.kaia', dbContent, `docs: complete tasks from merged PR #${prNumber}`);\n      }\n    } catch (error) {\n      console.error(`Error processing merged PR #${prNumber}:`, error.message);\n      throw error;\n    }\n  }\n}"
        }
      ],
      "metadata": {
        "type": "file_read_results"
      }
    }
  ],
  "updated": "2026-02-17T13:21:07.136Z"
}